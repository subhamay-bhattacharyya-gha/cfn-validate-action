name: 'CloudFormation Template Validator'
description: 'Validates CloudFormation templates, nested templates, and parameters files with comprehensive error reporting and artifact generation. Requires repository checkout and AWS credentials to be configured by caller workflow.'
author: 'Subhamay Bhattacharyya'
branding:
  icon: 'check-circle'
  color: 'orange'

inputs:
  cloudformation-dir:
    description: 'Directory containing CloudFormation templates'
    required: false
    default: '.'
  template-file:
    description: 'Main CloudFormation template filename'
    required: false
    default: 'template.yaml'
  parameters:
    description: 'CloudFormation parameters as JSON array string in format: [{"ParameterName":"string","ParameterValue":"string"}]'
    required: false
    default: ''
  aws-region:
    description: 'AWS region for validation'
    required: false
    default: 'us-east-1'
  aws-role-arn:
    description: 'AWS IAM role ARN for authentication'
    required: true
  github-token:
    description: 'GitHub token for artifact upload'
    required: false
    default: ${{ github.token }}

outputs:
  validation-result:
    description: 'Overall validation result (success/failure)'
    value: ${{ steps.summary.outputs.validation-result }}
  main-template-result:
    description: 'Main template validation result (success/failure)'
    value: ${{ steps.main-validation.outputs.result }}
  nested-templates-result:
    description: 'Nested templates validation result (success/failure/skipped)'
    value: ${{ steps.nested-validation.outputs.result }}
  parameters-result:
    description: 'Parameters file validation result (success/failure/skipped)'
    value: ${{ steps.parameters-validation.outputs.result }}

runs:
  using: 'composite'
  steps:
    - name: Validate main CloudFormation template
      id: main-validation
      shell: bash
      env:
        # AWS CLI configuration for retries and timeouts
        AWS_MAX_ATTEMPTS: 3
        AWS_RETRY_MODE: adaptive
        AWS_CLI_READ_TIMEOUT: 300
        AWS_CLI_CONNECT_TIMEOUT: 60
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üîç Starting main CloudFormation template validation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üåç AWS Region: ${{ inputs.aws-region }}"
        echo "üîë AWS CLI Version: $(aws --version 2>&1 || echo 'AWS CLI not available')"
        echo "üìÅ Working Directory: $(pwd)"
        echo "::endgroup::"
        
        # Set environment variables with validation
        CLOUDFORMATION_DIR="${{ inputs.cloudformation-dir }}"
        TEMPLATE_FILE="${{ inputs.template-file }}"
        TEMPLATE_PATH="${{ github.workspace }}/${CLOUDFORMATION_DIR}/${TEMPLATE_FILE}"
        
        echo "::group::üìã Configuration"
        echo "üîç CloudFormation Directory: ${CLOUDFORMATION_DIR}"
        echo "üìÑ Template File: ${TEMPLATE_FILE}"
        echo "üìç Full Template Path: ${TEMPLATE_PATH}"
        echo "::endgroup::"
        
        echo "üîç Validating CloudFormation template: ${TEMPLATE_PATH}"
        
        # Validate input parameters
        if [[ -z "${CLOUDFORMATION_DIR}" ]]; then
          echo "::error::CloudFormation directory is empty or not specified"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=CloudFormation directory is empty" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        if [[ -z "${TEMPLATE_FILE}" ]]; then
          echo "::error::Template file name is empty or not specified"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file name is empty" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Check if CloudFormation directory exists
        if [[ ! -d "${CLOUDFORMATION_DIR}" ]]; then
          echo "::error::CloudFormation directory does not exist: ${CLOUDFORMATION_DIR}"
          echo "üìÅ Current directory contents:"
          ls -la . || echo "Unable to list current directory"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=CloudFormation directory not found: ${CLOUDFORMATION_DIR}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Check if template file exists
        if [[ ! -f "${TEMPLATE_PATH}" ]]; then
          echo "::error::Template file not found: ${TEMPLATE_PATH}"
          echo "üìÅ Available files in ${CLOUDFORMATION_DIR}:"
          ls -la "${CLOUDFORMATION_DIR}" 2>&1 || echo "Unable to list directory contents"
          
          # Try to find similar files
          echo "üîç Looking for similar template files..."
          find "${CLOUDFORMATION_DIR}" -maxdepth 2 -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) 2>/dev/null | head -10 || echo "No template files found"
          
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file not found: ${TEMPLATE_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "‚úÖ Template file found: ${TEMPLATE_PATH}"
        
        # Validate file is readable and not empty
        if [[ ! -r "${TEMPLATE_PATH}" ]]; then
          echo "::error::Template file is not readable: ${TEMPLATE_PATH}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file is not readable" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        FILE_SIZE=$(stat -f%z "${TEMPLATE_PATH}" 2>/dev/null || stat -c%s "${TEMPLATE_PATH}" 2>/dev/null || echo "0")
        if [[ "${FILE_SIZE}" -eq 0 ]]; then
          echo "::error::Template file is empty: ${TEMPLATE_PATH}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file is empty" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "üìè Template file size: ${FILE_SIZE} bytes"
        
        # Create output directory for validation results
        mkdir -p validation-output
        
        # Log template file preview for debugging
        echo "::group::üìÑ Template File Preview (first 10 lines)"
        head -10 "${TEMPLATE_PATH}" 2>/dev/null || echo "Unable to preview template file"
        echo "::endgroup::"
        
        # Validate template using AWS CLI with comprehensive error handling
        echo "üîÑ Running AWS CloudFormation template validation..."
        echo "‚è±Ô∏è Validation started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Function to perform AWS CLI validation with retry logic
        validate_template_with_retry() {
          local attempt=1
          local max_attempts=3
          local retry_delay=5
          
          while [[ $attempt -le $max_attempts ]]; do
            echo "üîÑ Validation attempt ${attempt}/${max_attempts}"
            
            # Set timeout for the AWS CLI command
            if timeout 300 aws cloudformation validate-template \
              --template-body "file://${TEMPLATE_PATH}" \
              --region "${{ inputs.aws-region }}" \
              --output json > validation-output/main-template-validation.json 2> validation-output/main-template-errors.log; then
              
              echo "‚úÖ Template validation successful on attempt ${attempt}!"
              return 0
            else
              local exit_code=$?
              echo "‚ùå Validation attempt ${attempt} failed with exit code: ${exit_code}"
              
              # Log error details for this attempt
              if [[ -f validation-output/main-template-errors.log ]]; then
                echo "::group::üîç Error details for attempt ${attempt}"
                cat validation-output/main-template-errors.log
                echo "::endgroup::"
                
                # Check for specific error types that shouldn't be retried
                if grep -q "ValidationError" validation-output/main-template-errors.log; then
                  echo "üö´ Template syntax error detected - not retrying"
                  return $exit_code
                fi
                
                if grep -q "AccessDenied\|UnauthorizedOperation\|InvalidUserID.NotFound" validation-output/main-template-errors.log; then
                  echo "üö´ Authentication/authorization error detected - not retrying"
                  return $exit_code
                fi
              fi
              
              if [[ $attempt -lt $max_attempts ]]; then
                echo "‚è≥ Waiting ${retry_delay} seconds before retry..."
                sleep $retry_delay
                retry_delay=$((retry_delay * 2))  # Exponential backoff
              fi
              
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå All validation attempts failed"
          return 1
        }
        
        # Execute validation with retry logic
        if validate_template_with_retry; then
          echo "‚è±Ô∏è Validation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Validate that the output file was created and is valid JSON
          if [[ ! -f validation-output/main-template-validation.json ]]; then
            echo "::error::Validation output file was not created"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error=Validation output file missing" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate JSON output
          if ! jq empty validation-output/main-template-validation.json 2>/dev/null; then
            echo "::error::Validation output is not valid JSON"
            echo "üîç Raw output content:"
            cat validation-output/main-template-validation.json 2>/dev/null || echo "Unable to read output file"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error=Invalid JSON in validation output" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Display template capabilities and parameters using jq
          echo "::group::üìã Template Details"
          
          # Extract and display description
          DESCRIPTION=$(jq -r '.Description // "No description provided"' validation-output/main-template-validation.json)
          echo "üìù Description: ${DESCRIPTION}"
          
          # Extract and display capabilities
          CAPABILITIES=$(jq -r '.Capabilities[]? // empty' validation-output/main-template-validation.json)
          if [[ -n "${CAPABILITIES}" ]]; then
            echo "üîê Required Capabilities:"
            echo "${CAPABILITIES}" | while read -r capability; do
              echo "  - ${capability}"
            done
            
            # Display capabilities reason if available
            CAPABILITIES_REASON=$(jq -r '.CapabilitiesReason // empty' validation-output/main-template-validation.json)
            if [[ -n "${CAPABILITIES_REASON}" ]]; then
              echo "üí° Reason: ${CAPABILITIES_REASON}"
            fi
          else
            echo "üîê No special capabilities required"
          fi
          
          # Extract and display parameters
          PARAMETERS=$(jq -r '.Parameters[]? // empty' validation-output/main-template-validation.json)
          if [[ -n "${PARAMETERS}" ]]; then
            echo "üìù Template Parameters:"
            jq -r '.Parameters[] | "  - \(.ParameterKey): \(.Description // "No description") (Default: \(.DefaultValue // "None"))"' validation-output/main-template-validation.json
            
            # Count parameters
            PARAM_COUNT=$(jq '.Parameters | length' validation-output/main-template-validation.json)
            echo "üìä Total parameters: ${PARAM_COUNT}"
          else
            echo "üìù No parameters defined in template"
          fi
          
          # Extract and display metadata if available
          METADATA=$(jq -r '.Metadata // empty' validation-output/main-template-validation.json)
          if [[ -n "${METADATA}" ]] && [[ "${METADATA}" != "null" ]]; then
            echo "üè∑Ô∏è Template includes metadata"
          fi
          
          echo "::endgroup::"
          
          # Set success outputs
          echo "result=success" >> $GITHUB_OUTPUT
          echo "template-path=${TEMPLATE_PATH}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          
        else
          echo "‚ùå Template validation failed after all retry attempts!"
          echo "‚è±Ô∏è Validation failed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Comprehensive error analysis and reporting
          echo "::group::üîç Detailed Error Analysis"
          
          if [[ -f validation-output/main-template-errors.log ]]; then
            echo "üìÑ Raw error output:"
            cat validation-output/main-template-errors.log
            echo ""
            
            # Extract and categorize different types of errors
            ERROR_CONTENT=$(cat validation-output/main-template-errors.log)
            
            # Try multiple methods to extract error messages
            ERROR_MESSAGE=""
            
            # Method 1: Extract JSON error message
            JSON_ERROR=$(echo "${ERROR_CONTENT}" | grep -o '"message":"[^"]*"' | sed 's/"message":"\([^"]*\)"/\1/' | head -1)
            if [[ -n "${JSON_ERROR}" ]]; then
              ERROR_MESSAGE="${JSON_ERROR}"
            fi
            
            # Method 2: Extract ValidationError
            if [[ -z "${ERROR_MESSAGE}" ]]; then
              VALIDATION_ERROR=$(echo "${ERROR_CONTENT}" | grep -o "ValidationError[^:]*: [^\\n]*" | head -1)
              if [[ -n "${VALIDATION_ERROR}" ]]; then
                ERROR_MESSAGE="${VALIDATION_ERROR}"
              fi
            fi
            
            # Method 3: Extract any error line
            if [[ -z "${ERROR_MESSAGE}" ]]; then
              ERROR_MESSAGE=$(echo "${ERROR_CONTENT}" | grep -i "error" | head -1)
            fi
            
            # Method 4: Use first non-empty line
            if [[ -z "${ERROR_MESSAGE}" ]]; then
              ERROR_MESSAGE=$(echo "${ERROR_CONTENT}" | grep -v "^$" | head -1)
            fi
            
            # Categorize error types for better user guidance
            if echo "${ERROR_CONTENT}" | grep -q "ValidationError"; then
              echo "üè∑Ô∏è Error Type: Template Syntax/Structure Error"
              echo "üí° Suggestion: Check your CloudFormation template syntax and structure"
            elif echo "${ERROR_CONTENT}" | grep -q "AccessDenied\|UnauthorizedOperation"; then
              echo "üè∑Ô∏è Error Type: AWS Authentication/Authorization Error"
              echo "üí° Suggestion: Check your AWS credentials and IAM permissions"
            elif echo "${ERROR_CONTENT}" | grep -q "InvalidUserID.NotFound"; then
              echo "üè∑Ô∏è Error Type: AWS Account/User Error"
              echo "üí° Suggestion: Verify your AWS account configuration"
            elif echo "${ERROR_CONTENT}" | grep -q "RequestLimitExceeded\|Throttling"; then
              echo "üè∑Ô∏è Error Type: AWS API Rate Limiting"
              echo "üí° Suggestion: The validation was rate limited, try again later"
            elif echo "${ERROR_CONTENT}" | grep -q "ServiceUnavailable\|InternalError"; then
              echo "üè∑Ô∏è Error Type: AWS Service Error"
              echo "üí° Suggestion: AWS CloudFormation service may be experiencing issues"
            else
              echo "üè∑Ô∏è Error Type: Unknown Error"
              echo "üí° Suggestion: Check the error details above for more information"
            fi
            
            # Create appropriate GitHub error annotation
            if [[ -n "${ERROR_MESSAGE}" ]]; then
              echo "::error title=CloudFormation Validation Failed::${ERROR_MESSAGE}"
            else
              echo "::error title=CloudFormation Validation Failed::Template validation failed. Check logs for details."
            fi
            
          else
            echo "‚ùå No error log file found"
            ERROR_MESSAGE="Template validation failed with no error details"
            echo "::error title=CloudFormation Validation Failed::${ERROR_MESSAGE}"
          fi
          
          echo "::endgroup::"
          
          # Set failure outputs
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "template-path=${TEMPLATE_PATH}" >> $GITHUB_OUTPUT
          echo "error=${ERROR_MESSAGE:-"Template validation failed"}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          
          exit 1
        fi

    - name: Validate nested CloudFormation templates
      id: nested-validation
      if: steps.main-validation.outputs.result == 'success'
      shell: bash
      env:
        # AWS CLI configuration for retries and timeouts
        AWS_MAX_ATTEMPTS: 3
        AWS_RETRY_MODE: adaptive
        AWS_CLI_READ_TIMEOUT: 300
        AWS_CLI_CONNECT_TIMEOUT: 60
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üîç Starting nested CloudFormation templates validation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üåç AWS Region: ${{ inputs.aws-region }}"
        echo "::endgroup::"
        
        # Set environment variables
        CLOUDFORMATION_DIR="${{ inputs.cloudformation-dir }}"
        NESTED_DIR="${CLOUDFORMATION_DIR}/nested-templates"
        
        echo "::group::üìã Configuration"
        echo "üîç CloudFormation Directory: ${CLOUDFORMATION_DIR}"
        echo "üìÅ Nested Templates Directory: ${NESTED_DIR}"
        echo "::endgroup::"
        
        echo "üîç Checking for nested templates in: ${NESTED_DIR}"
        
        # Check if nested templates directory exists
        if [[ ! -d "${NESTED_DIR}" ]]; then
          echo "‚è≠Ô∏è No nested templates directory found. Skipping nested template validation."
          echo "üí° To include nested template validation, create a 'nested-templates' directory in your CloudFormation directory"
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No nested templates directory found" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üìÅ Found nested templates directory: ${NESTED_DIR}"
        
        # Check directory permissions
        if [[ ! -r "${NESTED_DIR}" ]]; then
          echo "::error::Nested templates directory is not readable: ${NESTED_DIR}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "message=Nested templates directory is not readable" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Find all YAML and JSON files in nested directory
        echo "üîÑ Searching for CloudFormation templates..."
        echo "::group::üîç Template Discovery"
        
        # Use more robust find command with error handling
        NESTED_TEMPLATES=""
        if NESTED_TEMPLATES=$(find "${NESTED_DIR}" -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) 2>/dev/null); then
          echo "‚úÖ Template search completed successfully"
        else
          echo "‚ö†Ô∏è Warning: Error occurred during template search, but continuing..."
          NESTED_TEMPLATES=""
        fi
        
        # Additional search for hidden or unusual files
        echo "üìä Directory contents:"
        ls -la "${NESTED_DIR}" 2>/dev/null || echo "Unable to list directory contents"
        
        echo "::endgroup::"
        
        if [[ -z "${NESTED_TEMPLATES}" ]]; then
          echo "‚è≠Ô∏è No CloudFormation template files found in nested directory. Skipping validation."
          echo "üí° Supported file extensions: .yaml, .yml, .json"
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No template files found in nested directory" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üìã Found nested templates:"
        TEMPLATE_COUNT=0
        while IFS= read -r template; do
          [[ -z "${template}" ]] && continue
          echo "  - ${template}"
          ((TEMPLATE_COUNT++))
        done <<< "${NESTED_TEMPLATES}"
        
        echo "üìä Total templates to validate: ${TEMPLATE_COUNT}"
        
        # Create output directory for nested validation results
        mkdir -p validation-output/nested
        
        # Initialize validation tracking variables
        VALIDATION_SUCCESS=true
        FAILED_TEMPLATES=""
        VALIDATED_COUNT=0
        FAILED_COUNT=0
        SKIPPED_COUNT=0
        
        # Function to validate a single template with retry logic
        validate_nested_template() {
          local template_path="$1"
          local template_name=$(basename "${template_path}")
          local output_file="validation-output/nested/${template_name}-validation.json"
          local error_file="validation-output/nested/${template_name}-errors.log"
          local attempt=1
          local max_attempts=3
          local retry_delay=2
          
          echo "::group::üîç Validating ${template_name}"
          echo "üìÑ Template: ${template_path}"
          echo "üìè File size: $(stat -f%z "${template_path}" 2>/dev/null || stat -c%s "${template_path}" 2>/dev/null || echo "unknown") bytes"
          
          # Check if file is readable and not empty
          if [[ ! -r "${template_path}" ]]; then
            echo "::error::Template file is not readable: ${template_path}"
            echo "‚ùå ${template_name}: File not readable"
            echo "::endgroup::"
            return 1
          fi
          
          local file_size=$(stat -f%z "${template_path}" 2>/dev/null || stat -c%s "${template_path}" 2>/dev/null || echo "0")
          if [[ "${file_size}" -eq 0 ]]; then
            echo "::warning::Template file is empty: ${template_path}"
            echo "‚è≠Ô∏è ${template_name}: Skipping empty file"
            echo "::endgroup::"
            return 2  # Special return code for skipped files
          fi
          
          # Show file preview for debugging
          echo "üìÑ Template preview (first 5 lines):"
          head -5 "${template_path}" 2>/dev/null | sed 's/^/  /' || echo "  Unable to preview file"
          
          while [[ $attempt -le $max_attempts ]]; do
            echo "üîÑ Validation attempt ${attempt}/${max_attempts} for ${template_name}"
            
            # Clear previous attempt files
            rm -f "${output_file}" "${error_file}"
            
            if timeout 300 aws cloudformation validate-template \
              --template-body "file://${template_path}" \
              --region "${{ inputs.aws-region }}" \
              --output json > "${output_file}" 2> "${error_file}"; then
              
              echo "‚úÖ ${template_name}: Validation successful on attempt ${attempt}!"
              
              # Validate output file
              if [[ -f "${output_file}" ]] && jq empty "${output_file}" 2>/dev/null; then
                # Display basic template info
                local description=$(jq -r '.Description // "No description"' "${output_file}")
                echo "üìù Description: ${description}"
                
                # Show capabilities if any
                local capabilities=$(jq -r '.Capabilities[]? // empty' "${output_file}")
                if [[ -n "${capabilities}" ]]; then
                  echo "üîê Capabilities: $(echo "${capabilities}" | tr '\n' ', ' | sed 's/,$//')"
                fi
                
                # Show parameter count
                local param_count=$(jq '.Parameters | length' "${output_file}" 2>/dev/null || echo "0")
                echo "üìä Parameters: ${param_count}"
                
                echo "::endgroup::"
                return 0
              else
                echo "‚ö†Ô∏è Warning: Invalid output file generated, treating as failure"
                echo "::endgroup::"
                return 1
              fi
              
            else
              local exit_code=$?
              echo "‚ùå Validation attempt ${attempt} failed with exit code: ${exit_code}"
              
              # Analyze error for retry decision
              local should_retry=true
              if [[ -f "${error_file}" ]]; then
                local error_content=$(cat "${error_file}")
                
                # Don't retry on syntax errors or auth errors
                if echo "${error_content}" | grep -q "ValidationError\|AccessDenied\|UnauthorizedOperation\|InvalidUserID.NotFound"; then
                  should_retry=false
                fi
                
                echo "üîç Error preview:"
                head -2 "${error_file}" | sed 's/^/  /' || echo "  No error details available"
              fi
              
              if [[ $attempt -lt $max_attempts ]] && [[ "$should_retry" == "true" ]]; then
                echo "‚è≥ Waiting ${retry_delay} seconds before retry..."
                sleep $retry_delay
                retry_delay=$((retry_delay * 2))
              else
                if [[ "$should_retry" == "false" ]]; then
                  echo "üö´ Error type detected that should not be retried"
                fi
                break
              fi
              
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå ${template_name}: All validation attempts failed"
          echo "::endgroup::"
          return 1
        }
        
        # Validate each nested template
        echo "üîÑ Validating nested templates..."
        echo "‚è±Ô∏è Validation started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        while IFS= read -r template_path; do
          [[ -z "${template_path}" ]] && continue
          
          template_name=$(basename "${template_path}")
          
          # Call validation function
          if validate_nested_template "${template_path}"; then
            ((VALIDATED_COUNT++))
          elif [[ $? -eq 2 ]]; then
            # File was skipped (empty)
            ((SKIPPED_COUNT++))
          else
            # Validation failed
            VALIDATION_SUCCESS=false
            FAILED_TEMPLATES="${FAILED_TEMPLATES}${template_name} "
            ((FAILED_COUNT++))
            
            # Enhanced error reporting
            error_file="validation-output/nested/${template_name}-errors.log"
            if [[ -f "${error_file}" ]]; then
              echo "::group::üîç Detailed Error Analysis for ${template_name}"
              
              local error_content=$(cat "${error_file}")
              
              # Extract and categorize error message
              local error_message=""
              
              # Try multiple extraction methods
              if error_message=$(echo "${error_content}" | grep -o '"message":"[^"]*"' | sed 's/"message":"\([^"]*\)"/\1/' | head -1); then
                echo "üìÑ Extracted error: ${error_message}"
              elif error_message=$(echo "${error_content}" | grep -o "ValidationError[^:]*: [^\\n]*" | head -1); then
                echo "üìÑ Validation error: ${error_message}"
              else
                error_message=$(echo "${error_content}" | grep -v "^$" | head -1)
                echo "üìÑ Raw error: ${error_message}"
              fi
              
              # Categorize error type
              if echo "${error_content}" | grep -q "ValidationError"; then
                echo "üè∑Ô∏è Error Type: Template Syntax/Structure Error"
                echo "::error title=Nested Template Syntax Error::${template_name}: ${error_message}"
              elif echo "${error_content}" | grep -q "AccessDenied\|UnauthorizedOperation"; then
                echo "üè∑Ô∏è Error Type: AWS Authentication/Authorization Error"
                echo "::error title=Nested Template Auth Error::${template_name}: ${error_message}"
              else
                echo "üè∑Ô∏è Error Type: Unknown Error"
                echo "::error title=Nested Template Validation Failed::${template_name}: ${error_message}"
              fi
              
              echo "üìÑ Full error log:"
              cat "${error_file}" | sed 's/^/  /'
              echo "::endgroup::"
            else
              echo "::error title=Nested Template Validation Failed::${template_name}: No error details available"
            fi
          fi
          
        done <<< "${NESTED_TEMPLATES}"
        
        echo "‚è±Ô∏è Validation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Generate comprehensive summary and set outputs
        echo ""
        echo "::group::üìä Nested Templates Validation Summary"
        echo "üìã Validation Results:"
        echo "  Total templates found: $((VALIDATED_COUNT + FAILED_COUNT + SKIPPED_COUNT))"
        echo "  Successfully validated: ${VALIDATED_COUNT}"
        echo "  Failed validation: ${FAILED_COUNT}"
        echo "  Skipped (empty files): ${SKIPPED_COUNT}"
        
        if [[ ${FAILED_COUNT} -gt 0 ]]; then
          echo "  Failed templates: ${FAILED_TEMPLATES}"
        fi
        echo "::endgroup::"
        
        if [[ "${VALIDATION_SUCCESS}" == "true" ]]; then
          if [[ ${VALIDATED_COUNT} -gt 0 ]]; then
            echo "‚úÖ All nested templates validated successfully!"
            echo "result=success" >> $GITHUB_OUTPUT
            echo "message=All ${VALIDATED_COUNT} nested templates validated successfully" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è No templates were validated (all were skipped)"
            echo "result=skipped" >> $GITHUB_OUTPUT
            echo "message=All nested templates were skipped (empty files)" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Some nested templates failed validation!"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "message=${FAILED_COUNT} nested templates failed validation" >> $GITHUB_OUTPUT
          echo "failed-templates=${FAILED_TEMPLATES}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Set common outputs
        echo "validated-count=${VALIDATED_COUNT}" >> $GITHUB_OUTPUT
        echo "failed-count=${FAILED_COUNT}" >> $GITHUB_OUTPUT
        echo "skipped-count=${SKIPPED_COUNT}" >> $GITHUB_OUTPUT
        echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

    - name: Validate parameters file
      id: parameters-validation
      if: steps.main-validation.outputs.result == 'success'
      shell: bash
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üîç Starting parameters validation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üîß jq Version: $(jq --version 2>&1 || echo 'jq not available')"
        echo "::endgroup::"
        
        # Set environment variables with validation
        CLOUDFORMATION_DIR="${{ inputs.cloudformation-dir }}"
        PARAMETERS_INPUT="${{ inputs.parameters }}"
        
        # Function to display comprehensive error examples and guidance
        show_parameter_format_help() {
          local error_context="$1"  # "json", "structure", "edge-case", or "general"
          
          echo ""
          echo "üìñ CloudFormation Parameters Input Format Guide:"
          echo ""
          echo "‚úÖ Correct format:"
          echo '[{"ParameterName": "string", "ParameterValue": "string"}]'
          echo ""
          echo "üìÑ Complete examples:"
          echo ""
          echo "Empty parameters (no validation needed):"
          echo '[]'
          echo ""
          echo "Single parameter:"
          echo '[{"ParameterName": "Environment", "ParameterValue": "production"}]'
          echo ""
          echo "Multiple parameters:"
          cat << 'EOF'
            [
              {"ParameterName": "Environment", "ParameterValue": "production"},
              {"ParameterName": "InstanceType", "ParameterValue": "t3.micro"},
              {"ParameterName": "KeyName", "ParameterValue": "my-key-pair"},
              {"ParameterName": "VpcId", "ParameterValue": "vpc-12345678"}
            ]
            EOF
          echo ""
          
          case "${error_context}" in
            "json")
              echo "üö´ Common JSON syntax errors to avoid:"
              echo ""
              echo "‚ùå Missing quotes:"
              echo '[{ParameterName: Environment, ParameterValue: production}]'
              echo ""
              echo "‚ùå Single quotes (use double quotes):"
              echo "[{'ParameterName': 'Environment', 'ParameterValue': 'production'}]"
              echo ""
              echo "‚ùå Trailing comma:"
              echo '[{"ParameterName": "Environment", "ParameterValue": "production",}]'
              echo ""
              echo "‚ùå Unescaped quotes in values:"
              echo '[{"ParameterName": "Message", "ParameterValue": "Hello "World""}]'
              echo "‚úÖ Properly escaped:"
              echo '[{"ParameterName": "Message", "ParameterValue": "Hello \"World\""}]'
              ;;
            "structure")
              echo "üö´ Common structure errors to avoid:"
              echo ""
              echo "‚ùå Object instead of array:"
              echo '{"ParameterName": "Environment", "ParameterValue": "production"}'
              echo ""
              echo "‚ùå Wrong field names:"
              echo '[{"ParameterKey": "Environment", "ParameterValue": "production"}]'
              echo ""
              echo "‚ùå Missing required fields:"
              echo '[{"ParameterName": "Environment"}]'
              echo ""
              echo "‚ùå Non-string values:"
              echo '[{"ParameterName": "Port", "ParameterValue": 8080}]'
              echo "‚úÖ String values:"
              echo '[{"ParameterName": "Port", "ParameterValue": "8080"}]'
              ;;
            "edge-case")
              echo "üí° Edge cases and best practices:"
              echo ""
              echo "‚úÖ Empty parameter value (allowed):"
              echo '[{"ParameterName": "OptionalParam", "ParameterValue": ""}]'
              echo ""
              echo "‚úÖ Special characters in values:"
              echo '[{"ParameterName": "S3Path", "ParameterValue": "s3://bucket/path/file.txt"}]'
              echo ""
              echo "‚ö†Ô∏è Avoid very long parameter names (>255 chars)"
              echo "‚ö†Ô∏è Avoid very long parameter values (>4096 chars)"
              echo "‚ö†Ô∏è Parameter names should be alphanumeric for best compatibility"
              ;;
          esac
          
          echo ""
          echo "üîó For more information, see CloudFormation documentation:"
          echo "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html"
        }
        
        # Function to parse and validate parameters input
        parse_parameters_input() {
          local parameters_input="$1"
          local temp_file="validation-output/parameters/input-parameters.json"
          
          echo "::group::üîç Parsing Parameters Input"
          echo "üìù Processing parameters from input..."
          
          # Create output directory
          mkdir -p validation-output/parameters
          
          # Check if input is empty
          if [[ -z "${parameters_input}" ]]; then
            echo "‚ö†Ô∏è Parameters input is empty"
            echo "üí° If you don't need parameters, you can:"
            echo "  - Omit the 'parameters' input entirely, or"
            echo "  - Use an empty array: []"
            echo ""
            echo "üìÑ Example of empty parameters:"
            echo 'parameters: "[]"'
            echo "::endgroup::"
            return 1
          fi
          
          # Pre-validation checks for common mistakes
          echo "üîç Performing pre-validation checks..."
          
          # Check for obvious non-JSON content
          if [[ "${parameters_input}" != \[* ]] && [[ "${parameters_input}" != \{* ]]; then
            echo "‚ùå Parameters input doesn't appear to be JSON!"
            echo "üîç Input starts with: ${parameters_input:0:50}..."
            echo ""
            echo "üí° Common mistakes:"
            echo "  - Forgetting to wrap in quotes in YAML"
            echo "  - Using shell variable syntax instead of JSON"
            echo "  - Providing plain text instead of JSON"
            echo ""
            echo "üìÑ Correct YAML usage:"
            echo 'parameters: "[{\"ParameterName\": \"Environment\", \"ParameterValue\": \"production\"}]"'
            echo ""
            show_parameter_format_help "json"
            echo "::error title=Parameters Input Format Error::Input doesn't appear to be valid JSON format"
            echo "::endgroup::"
            return 1
          fi
          
          # Check for common YAML multiline mistakes
          if echo "${parameters_input}" | grep -q $'\n'; then
            echo "‚ö†Ô∏è Warning: Parameters input contains newlines"
            echo "üí° If using YAML multiline syntax, ensure proper JSON formatting"
            echo ""
            echo "üìÑ YAML multiline example:"
            cat << 'EOF'
              parameters: |
                [
                  {"ParameterName": "Environment", "ParameterValue": "production"},
                  {"ParameterName": "InstanceType", "ParameterValue": "t3.micro"}
                ]
              EOF
          fi
          
          # Validate JSON syntax
          echo "üîÑ Validating JSON syntax..."
          if ! echo "${parameters_input}" | jq empty 2> validation-output/parameters/input-json-errors.log; then
            echo "‚ùå Invalid JSON format in parameters input!"
            
            if [[ -f validation-output/parameters/input-json-errors.log ]]; then
              local error_content=$(cat validation-output/parameters/input-json-errors.log)
              echo "üîç JSON Error Details:"
              echo "${error_content}"
              
              # Extract and analyze specific error types
              local error_message=$(echo "${error_content}" | head -1)
              local error_type="Generic JSON Error"
              
              # Categorize common JSON errors for better user guidance
              if echo "${error_content}" | grep -q "parse error.*Expected.*at line"; then
                error_type="JSON Syntax Error"
                local line_info=$(echo "${error_content}" | grep -o "at line [0-9]*" | head -1)
                if [[ -n "${line_info}" ]]; then
                  echo "üìç Error location: ${line_info}"
                fi
              elif echo "${error_content}" | grep -q "Invalid escape sequence"; then
                error_type="JSON Escape Sequence Error"
              elif echo "${error_content}" | grep -q "Unexpected end of JSON input"; then
                error_type="Incomplete JSON Error"
              elif echo "${error_content}" | grep -q "Unexpected token"; then
                error_type="JSON Token Error"
              fi
              
              echo "üè∑Ô∏è Error Type: ${error_type}"
              echo "::error title=Parameters Input JSON Error (${error_type})::${error_message}"
            else
              echo "::error title=Parameters Input JSON Error::Invalid JSON format with no error details"
            fi
            
            show_parameter_format_help "json"
            
            echo "::endgroup::"
            return 1
          fi
          
          echo "‚úÖ JSON syntax is valid"
          
          # Save input to temporary file for further processing
          echo "${parameters_input}" > "${temp_file}"
          
          # Validate structure - ensure it's an array
          echo "üìã Checking if root element is an array..."
          if ! jq -e 'type == "array"' "${temp_file}" > /dev/null 2>&1; then
            echo "‚ùå Parameters input structure validation failed!"
            echo "üîç Structure Error: Parameters input must be a JSON array"
            
            local current_type=$(jq -r 'type' "${temp_file}" 2>/dev/null || echo "unknown")
            echo "üìÑ Current root type: ${current_type}"
            echo ""
            echo "üìñ Expected format:"
            echo '[{"ParameterName": "string", "ParameterValue": "string"}]'
            echo ""
            
            # Provide specific guidance based on the detected type
            case "${current_type}" in
              "object")
                echo "üí° Detected JSON object - you need to wrap it in an array:"
                echo ""
                echo "‚ùå Incorrect (object):"
                echo '{"ParameterName": "Environment", "ParameterValue": "production"}'
                echo ""
                echo "‚úÖ Correct (array of objects):"
                echo '[{"ParameterName": "Environment", "ParameterValue": "production"}]'
                ;;
              "string")
                echo "üí° Detected string value - parameters must be an array of objects:"
                echo ""
                echo "‚ùå Incorrect (string):"
                echo '"Environment=production"'
                echo ""
                echo "‚úÖ Correct (array of objects):"
                echo '[{"ParameterName": "Environment", "ParameterValue": "production"}]'
                ;;
              "number"|"boolean")
                echo "üí° Detected ${current_type} value - parameters must be an array of objects:"
                echo ""
                echo "‚úÖ Correct format:"
                echo '[{"ParameterName": "Environment", "ParameterValue": "production"}]'
                ;;
              "null")
                echo "üí° Detected null value - use empty array for no parameters:"
                echo ""
                echo "‚úÖ Correct format for no parameters:"
                echo '[]'
                ;;
              *)
                echo "üí° Unknown type detected - ensure you're providing a JSON array"
                ;;
            esac
            
            show_parameter_format_help "structure"
            
            echo "::error title=Parameters Input Structure Error::Parameters input must be a JSON array of parameter objects (current type: ${current_type})"
            echo "::endgroup::"
            return 1
          fi
          
          echo "‚úÖ Root element is an array"
          
          # Check array length
          local param_count=$(jq 'length' "${temp_file}")
          echo "üìä Array length: ${param_count}"
          
          if [[ "${param_count}" -eq 0 ]]; then
            echo "‚ö†Ô∏è Parameters input is an empty array"
            echo "‚úÖ Structure is valid but no parameters defined"
            echo "üí° Empty array is valid - parameter validation will be skipped"
            echo "::endgroup::"
            return 0
          fi
          
          # Validate each parameter object structure
          echo "üîÑ Validating individual parameter objects..."
          
          local structure_errors=""
          local jq_error_file="validation-output/parameters/structure-validation-errors.log"
          
          # Clear previous error log
          rm -f "${jq_error_file}"
          
          if structure_errors=$(jq -r '
            to_entries[] | 
            select(
              (.value | type != "object") or 
              (.value | has("ParameterName") | not) or 
              (.value | has("ParameterValue") | not) or
              (.value.ParameterName | type != "string") or
              (.value.ParameterValue | type != "string") or
              (.value.ParameterName == "")
            ) | 
            "Parameter at index \(.key): \(
              if (.value | type != "object") then "must be an object (currently: \(.value | type))"
              elif (.value | has("ParameterName") | not) then "missing required ParameterName field"
              elif (.value | has("ParameterValue") | not) then "missing required ParameterValue field"
              elif (.value.ParameterName | type != "string") then "ParameterName must be a string (currently: \(.value.ParameterName | type))"
              elif (.value.ParameterValue | type != "string") then "ParameterValue must be a string (currently: \(.value.ParameterValue | type))"
              elif (.value.ParameterName == "") then "ParameterName cannot be empty"
              else "unknown structural error"
              end
            )"
          ' "${temp_file}" 2> "${jq_error_file}"); then
            
            if [[ -n "${structure_errors}" ]]; then
              echo "‚ùå Parameters input structure validation failed!"
              echo "üîç Structure Validation Errors:"
              echo "${structure_errors}"
              echo ""
              echo "üìñ Expected format for each parameter:"
              echo '{"ParameterName": "string", "ParameterValue": "string"}'
              show_parameter_format_help "structure"
              
              # Create GitHub error annotations for each structure error
              local error_count=0
              while IFS= read -r error_line; do
                [[ -z "${error_line}" ]] && continue
                echo "::error title=Parameter Input Structure Error::${error_line}"
                ((error_count++))
              done <<< "${structure_errors}"
              
              echo "üìä Total structure errors: ${error_count}"
              echo "::endgroup::"
              return 1
            fi
          else
            # jq command failed - this indicates a more serious issue
            echo "‚ùå Critical error during structure validation!"
            
            if [[ -f "${jq_error_file}" ]]; then
              local jq_error_content=$(cat "${jq_error_file}")
              echo "üîç jq Error Details:"
              echo "${jq_error_content}"
              echo "::error title=Parameter Structure Validation Failed::jq processing error: ${jq_error_content}"
            else
              echo "::error title=Parameter Structure Validation Failed::Unknown error during structure validation"
            fi
            
            echo ""
            echo "üí° This error suggests the JSON structure is severely malformed"
            show_parameter_format_help "general"
            echo "::endgroup::"
            return 1
          fi
          
          echo "‚úÖ Parameters input structure validation successful!"
          
          # Additional edge case validation
          echo "üîÑ Performing additional edge case validation..."
          
          # Check for duplicate parameter names
          local duplicate_names=""
          if duplicate_names=$(jq -r '[.[].ParameterName] | group_by(.) | map(select(length > 1)) | flatten | unique | .[]?' "${temp_file}" 2>/dev/null); then
            if [[ -n "${duplicate_names}" ]]; then
              echo "‚ùå Duplicate parameter names detected!"
              echo "üîç Duplicate parameter names:"
              local dup_count=0
              while IFS= read -r dup_name; do
                [[ -z "${dup_name}" ]] && continue
                echo "  - ${dup_name}"
                ((dup_count++))
              done <<< "${duplicate_names}"
              
              echo ""
              echo "üí° Each parameter name must be unique within the array"
              echo "üîß Fix: Remove or rename duplicate parameters"
              echo ""
              echo "üìÑ Example of corrected parameters:"
              cat << 'EOF'
                [
                  {"ParameterName": "Environment", "ParameterValue": "production"},
                  {"ParameterName": "EnvironmentType", "ParameterValue": "prod"}
                ]
                EOF
              
              local dup_names_list=$(echo "${duplicate_names}" | tr '\n' ', ' | sed 's/,$//')
              echo "::error title=Duplicate Parameter Names::Found ${dup_count} duplicate parameter names: ${dup_names_list}"
              echo "::endgroup::"
              return 1
            fi
          fi
          
          # Check for parameters with very long names or values (potential issues)
          local long_names=""
          if long_names=$(jq -r '.[] | select((.ParameterName | length) > 255) | .ParameterName' "${temp_file}" 2>/dev/null); then
            if [[ -n "${long_names}" ]]; then
              echo "‚ö†Ô∏è Warning: Parameters with very long names detected (>255 characters):"
              while IFS= read -r long_name; do
                [[ -z "${long_name}" ]] && continue
                local name_length=$(echo "${long_name}" | wc -c)
                echo "  - ${long_name:0:50}... (${name_length} characters)"
              done <<< "${long_names}"
              echo "üí° CloudFormation parameter names should typically be under 255 characters"
            fi
          fi
          
          local long_values=""
          if long_values=$(jq -r '.[] | select((.ParameterValue | length) > 4096) | .ParameterName' "${temp_file}" 2>/dev/null); then
            if [[ -n "${long_values}" ]]; then
              echo "‚ö†Ô∏è Warning: Parameters with very long values detected (>4096 characters):"
              while IFS= read -r param_name; do
                [[ -z "${param_name}" ]] && continue
                local value_length=$(jq -r --arg name "${param_name}" '.[] | select(.ParameterName == $name) | .ParameterValue | length' "${temp_file}")
                echo "  - ${param_name} (${value_length} characters)"
              done <<< "${long_values}"
              echo "üí° CloudFormation parameter values should typically be under 4096 characters"
            fi
          fi
          
          # Check for parameters with special characters that might cause issues
          local special_char_names=""
          if special_char_names=$(jq -r '.[] | select(.ParameterName | test("[^a-zA-Z0-9]")) | .ParameterName' "${temp_file}" 2>/dev/null); then
            if [[ -n "${special_char_names}" ]]; then
              echo "‚ö†Ô∏è Warning: Parameter names with special characters detected:"
              while IFS= read -r special_name; do
                [[ -z "${special_name}" ]] && continue
                echo "  - ${special_name}"
              done <<< "${special_char_names}"
              echo "üí° CloudFormation parameter names should contain only alphanumeric characters"
            fi
          fi
          
          echo "üìä Successfully parsed ${param_count} parameters from input"
          echo "::endgroup::"
          
          # Set the temp file path for use by calling function
          echo "${temp_file}"
          return 0
        }
        
        echo "::group::üìã Configuration"
        echo "üîç CloudFormation Directory: ${CLOUDFORMATION_DIR}"
        echo "üîß Parameters Input Length: ${#PARAMETERS_INPUT}"
        echo "::endgroup::"
        
        # Check if parameters input is provided
        PARAMETERS_DATA_FILE=""
        
        if [[ -z "${PARAMETERS_INPUT}" ]]; then
          echo "‚è≠Ô∏è No parameters provided. Skipping parameters validation."
          echo "üí° To include parameters validation, use 'parameters' input with JSON array format"
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No parameters provided" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üîç Using parameters from input"
        
        # Parse and validate parameters input
        if PARAMETERS_DATA_FILE=$(parse_parameters_input "${PARAMETERS_INPUT}"); then
          echo "‚úÖ Parameters input parsed successfully"
          echo "üìÑ Data file: ${PARAMETERS_DATA_FILE}"
        else
          echo "‚ùå Parameters input parsing failed"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Invalid parameters input format" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 1
        fi
        

        
        # Create output directory for parameters validation results
        mkdir -p validation-output/parameters
        
        # Log data preview for debugging
        echo "::group::üìÑ Parameters Data Preview"
        echo "üìÑ Input content preview (first 500 characters):"
        echo "${PARAMETERS_INPUT}" | head -c 500 | sed 's/^/  /' || echo "  Unable to preview input"
        if [[ ${#PARAMETERS_INPUT} -gt 500 ]]; then
          echo "  ... (truncated)"
        fi
        echo "::endgroup::"
        
        echo "‚úÖ JSON syntax already validated for input source"
        
        echo "‚úÖ Structure already validated for input source"
        
        # Get parameter count from the data file
        PARAM_COUNT=$(jq 'length' "${PARAMETERS_DATA_FILE}")
        echo "üìä Total parameters: ${PARAM_COUNT}"
        
        if [[ "${PARAM_COUNT}" -eq 0 ]]; then
          echo "‚ö†Ô∏è Parameters data is an empty array"
          echo "‚úÖ Structure is valid but no parameters defined"
          
          echo "result=success" >> $GITHUB_OUTPUT
          echo "parameters-count=0" >> $GITHUB_OUTPUT
          echo "message=Parameters are valid but empty" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_DATA_FILE}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Advanced validation and analysis
        echo "::group::üìä Parameters Analysis"
        
        # Display parameter keys and values on successful validation
        echo "üìã Parameters Summary:"
        echo "  Total parameters: ${PARAM_COUNT}"
        echo "  Source: input"
        echo ""
        
        # Extract and display all parameters with their keys and values
        echo "üìù Parameter Details:"
        if jq -r '.[] | "  üîë \(.ParameterName): \(.ParameterValue)"' "${PARAMETERS_DATA_FILE}" > validation-output/parameters/parameters-summary.txt 2>/dev/null; then
          cat validation-output/parameters/parameters-summary.txt
        else
          echo "  ‚ö†Ô∏è Unable to extract parameter details"
        fi
        
        # Create processed JSON for potential use by other steps
        if jq '[.[] | {key: .ParameterName, value: .ParameterValue}]' "${PARAMETERS_DATA_FILE}" > validation-output/parameters/parameters-processed.json 2>/dev/null; then
          echo "üìÑ Processed parameters saved to validation-output/parameters/parameters-processed.json"
        fi
        
        # Check for duplicate parameter keys
        echo "üîç Checking for duplicate parameter names..."
        local duplicate_keys=""
        if duplicate_keys=$(jq -r '[.[].ParameterName] | group_by(.) | map(select(length > 1)) | flatten | unique | .[]?' "${PARAMETERS_DATA_FILE}" 2>/dev/null); then
          if [[ -n "${duplicate_keys}" ]]; then
            echo ""
            echo "‚ö†Ô∏è Warning: Duplicate parameter names found:"
            local dup_count=0
            while IFS= read -r dup_key; do
              [[ -z "${dup_key}" ]] && continue
              echo "  - ${dup_key}"
              ((dup_count++))
            done <<< "${duplicate_keys}"
            
            local dup_keys_list=$(echo "${duplicate_keys}" | tr '\n' ', ' | sed 's/,$//')
            echo "::warning title=Duplicate Parameter Names::Found ${dup_count} duplicate parameter names: ${dup_keys_list}"
          else
            echo "‚úÖ No duplicate parameter names found"
          fi
        else
          echo "‚ö†Ô∏è Unable to check for duplicate names"
        fi
        
        # Check for empty parameter values
        echo "üîç Checking for empty parameter values..."
        local empty_values=""
        if empty_values=$(jq -r '.[] | select(.ParameterValue == "") | .ParameterName' "${PARAMETERS_DATA_FILE}" 2>/dev/null); then
          if [[ -n "${empty_values}" ]]; then
            echo "‚ö†Ô∏è Warning: Parameters with empty values found:"
            while IFS= read -r empty_key; do
              [[ -z "${empty_key}" ]] && continue
              echo "  - ${empty_key}"
            done <<< "${empty_values}"
            
            local empty_keys_list=$(echo "${empty_values}" | tr '\n' ', ' | sed 's/,$//')
            echo "::warning title=Empty Parameter Values::Parameters with empty values: ${empty_keys_list}"
          else
            echo "‚úÖ No empty parameter values found"
          fi
        fi
        
        # Generate parameter statistics
        echo "üìä Parameter Statistics:"
        local avg_key_length=$(jq -r '[.[].ParameterName | length] | add / length | floor' "${PARAMETERS_DATA_FILE}" 2>/dev/null || echo "unknown")
        local avg_value_length=$(jq -r '[.[].ParameterValue | length] | add / length | floor' "${PARAMETERS_DATA_FILE}" 2>/dev/null || echo "unknown")
        echo "  Average name length: ${avg_key_length} characters"
        echo "  Average value length: ${avg_value_length} characters"
        
        echo "::endgroup::"
        
        echo "‚è±Ô∏è Parameters validation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Set success outputs
        echo "result=success" >> $GITHUB_OUTPUT
        echo "parameters-count=${PARAM_COUNT}" >> $GITHUB_OUTPUT
        echo "parameters-path=${PARAMETERS_DATA_FILE}" >> $GITHUB_OUTPUT
        echo "message=${PARAM_COUNT} parameters validated successfully from input" >> $GITHUB_OUTPUT
        echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
        
        # Export parameter keys for potential use in summary
        local param_keys=""
        if param_keys=$(jq -r '[.[].ParameterName] | join(", ")' "${PARAMETERS_DATA_FILE}" 2>/dev/null); then
          echo "parameter-keys=${param_keys}" >> $GITHUB_OUTPUT
        else
          echo "parameter-keys=" >> $GITHUB_OUTPUT
        fi

    - name: Generate validation summary
      id: summary
      if: always()
      shell: bash
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üìä Starting validation summary generation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üîß Summary generation always runs regardless of previous step results"
        echo "::endgroup::"
        
        echo "üìä Generating comprehensive validation summary..."
        
        # Read validation results from previous steps with error handling
        echo "::group::üìã Collecting Validation Results"
        
        MAIN_RESULT="${{ steps.main-validation.outputs.result }}"
        NESTED_RESULT="${{ steps.nested-validation.outputs.result }}"
        PARAMETERS_RESULT="${{ steps.parameters-validation.outputs.result }}"
        
        echo "üîç Main template result: ${MAIN_RESULT:-"not available"}"
        echo "üîç Nested templates result: ${NESTED_RESULT:-"not available"}"
        echo "üîç Parameters result: ${PARAMETERS_RESULT:-"not available"}"
        
        # Get file paths with fallbacks
        TEMPLATE_PATH="${{ steps.main-validation.outputs.template-path }}"
        PARAMETERS_PATH="${{ steps.parameters-validation.outputs.parameters-path }}"
        
        echo "üìÑ Template path: ${TEMPLATE_PATH:-"not available"}"
        echo "üìÑ Parameters path: ${PARAMETERS_PATH:-"not available"}"
        
        # Get timestamps for tracking
        MAIN_TIMESTAMP="${{ steps.main-validation.outputs.validation-timestamp }}"
        NESTED_TIMESTAMP="${{ steps.nested-validation.outputs.validation-timestamp }}"
        PARAMETERS_TIMESTAMP="${{ steps.parameters-validation.outputs.validation-timestamp }}"
        
        echo "‚è±Ô∏è Main validation timestamp: ${MAIN_TIMESTAMP:-"not available"}"
        echo "‚è±Ô∏è Nested validation timestamp: ${NESTED_TIMESTAMP:-"not available"}"
        echo "‚è±Ô∏è Parameters validation timestamp: ${PARAMETERS_TIMESTAMP:-"not available"}"
        
        echo "::endgroup::"
        
        # Determine overall validation result with comprehensive logic
        echo "::group::üéØ Determining Overall Result"
        
        OVERALL_RESULT="success"
        FAILURE_REASONS=()
        
        # Check each validation step
        if [[ "${MAIN_RESULT}" == "failure" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Main template validation failed")
          echo "‚ùå Main template validation failed"
        elif [[ "${MAIN_RESULT}" == "success" ]]; then
          echo "‚úÖ Main template validation succeeded"
        elif [[ -z "${MAIN_RESULT}" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Main template validation did not complete")
          echo "‚ùì Main template validation did not complete"
        fi
        
        if [[ "${NESTED_RESULT}" == "failure" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Nested templates validation failed")
          echo "‚ùå Nested templates validation failed"
        elif [[ "${NESTED_RESULT}" == "success" ]]; then
          echo "‚úÖ Nested templates validation succeeded"
        elif [[ "${NESTED_RESULT}" == "skipped" ]]; then
          echo "‚è≠Ô∏è Nested templates validation was skipped"
        fi
        
        if [[ "${PARAMETERS_RESULT}" == "failure" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Parameters validation failed")
          echo "‚ùå Parameters validation failed"
        elif [[ "${PARAMETERS_RESULT}" == "success" ]]; then
          echo "‚úÖ Parameters validation succeeded"
        elif [[ "${PARAMETERS_RESULT}" == "skipped" ]]; then
          echo "‚è≠Ô∏è Parameters validation was skipped"
        fi
        
        echo "üéØ Overall result: ${OVERALL_RESULT}"
        if [[ ${#FAILURE_REASONS[@]} -gt 0 ]]; then
          echo "üìã Failure reasons:"
          for reason in "${FAILURE_REASONS[@]}"; do
            echo "  - ${reason}"
          done
        fi
        
        echo "::endgroup::"
        
        # Generate status indicators with error handling
        get_status_indicator() {
          case "$1" in
            "success") echo "‚úÖ" ;;
            "failure") echo "‚ùå" ;;
            "skipped") echo "‚è≠Ô∏è" ;;
            "") echo "‚ùì" ;;
            *) echo "‚ùì" ;;
          esac
        }
        
        MAIN_ICON=$(get_status_indicator "${MAIN_RESULT}")
        NESTED_ICON=$(get_status_indicator "${NESTED_RESULT}")
        PARAMETERS_ICON=$(get_status_indicator "${PARAMETERS_RESULT}")
        OVERALL_ICON=$(get_status_indicator "${OVERALL_RESULT}")
        
        echo "üé® Status icons: Main=${MAIN_ICON}, Nested=${NESTED_ICON}, Parameters=${PARAMETERS_ICON}, Overall=${OVERALL_ICON}"
        
        # Validate that GITHUB_STEP_SUMMARY is available
        if [[ -z "${GITHUB_STEP_SUMMARY:-}" ]]; then
          echo "::warning::GITHUB_STEP_SUMMARY environment variable is not set, summary will not be displayed"
          echo "üìÑ Summary would have been written to GitHub step summary"
        else
          echo "üìù Writing summary to: ${GITHUB_STEP_SUMMARY}"
        fi
        
        # Create comprehensive markdown summary for GitHub step summary
        echo "::group::üìù Generating Markdown Summary"
        
        # Function to safely write to step summary
        write_to_summary() {
          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            cat >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Summary content (would be written to GitHub step summary):"
            cat
          fi
        }
        
        # Generate the main summary
        write_to_summary << EOF
          # ${OVERALL_ICON} CloudFormation Validation Summary

          ## Overall Result: **${OVERALL_RESULT^^}**

          $(if [[ ${#FAILURE_REASONS[@]} -gt 0 ]]; then
            echo "### ‚ùå Failure Summary"
            for reason in "${FAILURE_REASONS[@]}"; do
              echo "- ${reason}"
            done
            echo ""
          fi)

          | Validation Type | Status | Result | Details |
          |---|---|---|---|
          | **Main Template** | ${MAIN_ICON} | **${MAIN_RESULT^^}** | \`${TEMPLATE_PATH:-"N/A"}\` |
          | **Nested Templates** | ${NESTED_ICON} | **${NESTED_RESULT^^}** | ${{ steps.nested-validation.outputs.message || 'N/A' }} |
          | **Parameters File** | ${PARAMETERS_ICON} | **${PARAMETERS_RESULT^^}** | \`${PARAMETERS_PATH:-"N/A"}\` |

          ---

          ## Validation Details

          ### ${MAIN_ICON} Main Template Validation
          - **File**: \`${TEMPLATE_PATH:-"Not specified"}\`
          - **Status**: ${MAIN_RESULT^^}
          $(if [[ -n "${MAIN_TIMESTAMP}" ]]; then echo "- **Timestamp**: ${MAIN_TIMESTAMP}"; fi)
          EOF
                  
                  # Add main template error details if failed
                  if [[ "${MAIN_RESULT}" == "failure" ]]; then
                    MAIN_ERROR="${{ steps.main-validation.outputs.error }}"
                    write_to_summary << EOF
          - **Error**: ${MAIN_ERROR:-"Unknown error"}
          EOF
        fi
        
        # Add nested templates details with comprehensive information
        write_to_summary << EOF

        ### ${NESTED_ICON} Nested Templates Validation
        - **Status**: ${NESTED_RESULT^^}
        $(if [[ -n "${NESTED_TIMESTAMP}" ]]; then echo "- **Timestamp**: ${NESTED_TIMESTAMP}"; fi)
        EOF
                
                if [[ "${NESTED_RESULT}" == "success" ]]; then
                  VALIDATED_COUNT="${{ steps.nested-validation.outputs.validated-count }}"
                  SKIPPED_COUNT="${{ steps.nested-validation.outputs.skipped-count }}"
                  write_to_summary << EOF
        - **Templates Validated**: ${VALIDATED_COUNT:-"0"}
        $(if [[ -n "${SKIPPED_COUNT}" ]] && [[ "${SKIPPED_COUNT}" != "0" ]]; then echo "- **Templates Skipped**: ${SKIPPED_COUNT}"; fi)
        - **Result**: All nested templates validated successfully
        EOF
                elif [[ "${NESTED_RESULT}" == "failure" ]]; then
                  VALIDATED_COUNT="${{ steps.nested-validation.outputs.validated-count }}"
                  FAILED_COUNT="${{ steps.nested-validation.outputs.failed-count }}"
                  SKIPPED_COUNT="${{ steps.nested-validation.outputs.skipped-count }}"
                  FAILED_TEMPLATES="${{ steps.nested-validation.outputs.failed-templates }}"
                  write_to_summary << EOF
        - **Templates Validated**: ${VALIDATED_COUNT:-"0"}
        - **Templates Failed**: ${FAILED_COUNT:-"0"}
        $(if [[ -n "${SKIPPED_COUNT}" ]] && [[ "${SKIPPED_COUNT}" != "0" ]]; then echo "- **Templates Skipped**: ${SKIPPED_COUNT}"; fi)
        - **Failed Templates**: ${FAILED_TEMPLATES:-"Unknown"}
        EOF
                else
                  NESTED_MESSAGE="${{ steps.nested-validation.outputs.message }}"
                  write_to_summary << EOF
        - **Result**: ${NESTED_MESSAGE:-"Nested templates validation was skipped"}
        EOF
                fi
                
                # Add parameters file details with comprehensive information
                write_to_summary << EOF

        ### ${PARAMETERS_ICON} Parameters File Validation
        - **File**: \`${PARAMETERS_PATH:-"Not specified"}\`
        - **Status**: ${PARAMETERS_RESULT^^}
        $(if [[ -n "${PARAMETERS_TIMESTAMP}" ]]; then echo "- **Timestamp**: ${PARAMETERS_TIMESTAMP}"; fi)
        EOF
                
                if [[ "${PARAMETERS_RESULT}" == "success" ]]; then
                  PARAM_COUNT="${{ steps.parameters-validation.outputs.parameters-count }}"
                  PARAM_KEYS="${{ steps.parameters-validation.outputs.parameter-keys }}"
                  write_to_summary << EOF
        - **Parameters Count**: ${PARAM_COUNT:-"0"}
        EOF
                  if [[ -n "${PARAM_KEYS}" ]] && [[ "${PARAM_KEYS}" != "" ]]; then
                    # Truncate parameter keys if too long for summary
                    if [[ ${#PARAM_KEYS} -gt 200 ]]; then
                      TRUNCATED_KEYS="${PARAM_KEYS:0:200}..."
                      write_to_summary << EOF
        - **Parameter Keys**: ${TRUNCATED_KEYS}
        EOF
                    else
                      write_to_summary << EOF
        - **Parameter Keys**: ${PARAM_KEYS}
        EOF
                    fi
                  fi
                elif [[ "${PARAMETERS_RESULT}" == "failure" ]]; then
                  PARAM_ERROR="${{ steps.parameters-validation.outputs.error }}"
                  write_to_summary << EOF
        - **Error**: ${PARAM_ERROR:-"Unknown error"}
        EOF
                else
                  PARAM_MESSAGE="${{ steps.parameters-validation.outputs.message }}"
                  write_to_summary << EOF
        - **Result**: ${PARAM_MESSAGE:-"Parameters validation was skipped"}
        EOF
                fi
                
                # Add comprehensive footer with artifact and configuration information
                write_to_summary << EOF

        ---

        ## üìÅ Artifacts

        Detailed validation results and logs have been uploaded as artifacts:
        - **Artifact Name**: \`cloudformation-validation-results-${{ github.run_id }}\`
        - **Retention**: 30 days
        - **Contents**: Validation output files, error logs, and detailed results

        ## üîß Action Configuration

        | Input | Value |
        |---|---|
        | **CloudFormation Directory** | \`${{ inputs.cloudformation-dir }}\` |
        | **Template File** | \`${{ inputs.template-file }}\` |
        | **AWS Region** | \`${{ inputs.aws-region }}\` |
        | **AWS Role ARN** | \`${{ inputs.aws-role-arn }}\` |

        ## üìä Execution Summary

        - **Workflow Run ID**: ${{ github.run_id }}
        - **Summary Generated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - **Repository**: ${{ github.repository }}
        - **Branch/Ref**: ${{ github.ref }}

        $(if [[ "${OVERALL_RESULT}" == "failure" ]]; then
          echo "## üîß Troubleshooting"
          echo ""
          echo "The validation failed. Check the detailed logs above and the uploaded artifacts for more information."
          echo ""
          echo "### Common Issues:"
          echo "- **Template Syntax Errors**: Check your CloudFormation template syntax"
          echo "- **AWS Authentication**: Verify your AWS credentials and IAM permissions"
          echo "- **File Paths**: Ensure template and parameter files exist at the specified paths"
          echo "- **JSON Format**: Verify parameters file is valid JSON with correct structure"
        fi)
        EOF
        
        echo "‚úÖ Markdown summary generated successfully"
        echo "::endgroup::"
        
        # Set output for overall validation result with error handling
        echo "::group::üì§ Setting Outputs"
        
        if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
          echo "validation-result=${OVERALL_RESULT}" >> "$GITHUB_OUTPUT"
          echo "summary-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$GITHUB_OUTPUT"
          echo "failure-count=${#FAILURE_REASONS[@]}" >> "$GITHUB_OUTPUT"
          
          # Export failure reasons as a comma-separated string
          if [[ ${#FAILURE_REASONS[@]} -gt 0 ]]; then
            IFS=','
            FAILURE_REASONS_STR="${FAILURE_REASONS[*]}"
            unset IFS
            echo "failure-reasons=${FAILURE_REASONS_STR}" >> "$GITHUB_OUTPUT"
          fi
          
          echo "‚úÖ Outputs set successfully"
        else
          echo "::warning::GITHUB_OUTPUT environment variable is not set"
          echo "üì§ Would have set validation-result=${OVERALL_RESULT}"
        fi
        
        echo "::endgroup::"
        
        # Final status report
        if [[ "${OVERALL_RESULT}" == "success" ]]; then
          echo "üéâ Validation summary generated successfully! All validations passed."
        else
          echo "üìã Validation summary generated successfully. Some validations failed - check details above."
        fi
        
        echo "‚è±Ô∏è Summary generation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

    - name: Upload validation artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: cloudformation-validation-results-${{ github.run_id }}
        path: |
          validation-output/
        retention-days: 30
        compression-level: 6
        if-no-files-found: warn
      env:
        # Ensure artifact upload has proper timeout and retry behavior
        ACTIONS_STEP_DEBUG: ${{ runner.debug }}
      continue-on-error: true
      id: upload-artifacts
      
    - name: Verify artifact upload
      if: always()
      shell: bash
      run: |
        set -euo pipefail
        
        echo "::group::üìÅ Artifact Upload Verification"
        echo "üîç Verifying artifact upload status"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Check if validation-output directory exists and has content
        if [[ -d "validation-output" ]]; then
          echo "‚úÖ Validation output directory exists"
          
          # Count files in validation-output
          FILE_COUNT=$(find validation-output -type f | wc -l | tr -d ' ')
          echo "üìä Total files in validation-output: ${FILE_COUNT}"
          
          if [[ "${FILE_COUNT}" -gt 0 ]]; then
            echo "üìã Validation output contents:"
            find validation-output -type f -exec ls -lh {} \; | sed 's/^/  /'
            
            # Calculate total size
            TOTAL_SIZE=$(du -sh validation-output 2>/dev/null | cut -f1 || echo "unknown")
            echo "üìè Total validation output size: ${TOTAL_SIZE}"
            
            # Show directory structure
            echo "üå≥ Directory structure:"
            tree validation-output 2>/dev/null || find validation-output -type d | sed 's/^/  /' || echo "  Unable to show directory structure"
            
          else
            echo "‚ö†Ô∏è Warning: Validation output directory is empty"
            echo "::warning::No validation output files were generated"
          fi
        else
          echo "‚ùå Validation output directory does not exist"
          echo "::warning::Validation output directory was not created"
        fi
        
        # Check artifact upload step result
        UPLOAD_OUTCOME="${{ steps.upload-artifacts.outcome }}"
        echo "üì§ Artifact upload outcome: ${UPLOAD_OUTCOME:-"not available"}"
        
        case "${UPLOAD_OUTCOME}" in
          "success")
            echo "‚úÖ Artifacts uploaded successfully"
            echo "üîó Artifact name: cloudformation-validation-results-${{ github.run_id }}"
            echo "‚è≥ Retention: 30 days"
            ;;
          "failure")
            echo "‚ùå Artifact upload failed"
            echo "::error::Failed to upload validation artifacts"
            ;;
          "skipped")
            echo "‚è≠Ô∏è Artifact upload was skipped"
            echo "::warning::Artifact upload was skipped"
            ;;
          *)
            echo "‚ùì Unknown artifact upload status: ${UPLOAD_OUTCOME}"
            echo "::warning::Unknown artifact upload status"
            ;;
        esac
        
        # Provide guidance for accessing artifacts
        if [[ "${UPLOAD_OUTCOME}" == "success" ]]; then
          echo ""
          echo "üí° To access the uploaded artifacts:"
          echo "  1. Go to the Actions tab in your GitHub repository"
          echo "  2. Click on this workflow run"
          echo "  3. Scroll down to the 'Artifacts' section"
          echo "  4. Download 'cloudformation-validation-results-${{ github.run_id }}'"
        fi
        
        echo "::endgroup::"
