name: 'CloudFormation Template Validator'
description: 'Validates CloudFormation templates, nested templates, and parameters files with comprehensive error reporting and artifact generation. Requires repository checkout and AWS credentials to be configured by caller workflow.'
author: 'Subhamay Bhattacharyya'
branding:
  icon: 'check-circle'
  color: 'orange'

inputs:
  cloudformation-dir:
    description: 'Directory containing CloudFormation templates'
    required: false
    default: '.'
  template-file:
    description: 'Main CloudFormation template filename'
    required: false
    default: 'template.yaml'
  parameters-file:
    description: 'Parameters file name'
    required: false
    default: 'parameters.json'
  aws-region:
    description: 'AWS region for validation'
    required: false
    default: 'us-east-1'
  aws-role-arn:
    description: 'AWS IAM role ARN for authentication'
    required: true
  github-token:
    description: 'GitHub token for artifact upload'
    required: false
    default: ${{ github.token }}

outputs:
  validation-result:
    description: 'Overall validation result (success/failure)'
    value: ${{ steps.summary.outputs.validation-result }}
  main-template-result:
    description: 'Main template validation result (success/failure)'
    value: ${{ steps.main-validation.outputs.result }}
  nested-templates-result:
    description: 'Nested templates validation result (success/failure/skipped)'
    value: ${{ steps.nested-validation.outputs.result }}
  parameters-result:
    description: 'Parameters file validation result (success/failure/skipped)'
    value: ${{ steps.parameters-validation.outputs.result }}

runs:
  using: 'composite'
  steps:
    - name: Validate main CloudFormation template
      id: main-validation
      shell: bash
      env:
        # AWS CLI configuration for retries and timeouts
        AWS_MAX_ATTEMPTS: 3
        AWS_RETRY_MODE: adaptive
        AWS_CLI_READ_TIMEOUT: 300
        AWS_CLI_CONNECT_TIMEOUT: 60
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üîç Starting main CloudFormation template validation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üåç AWS Region: ${{ inputs.aws-region }}"
        echo "üîë AWS CLI Version: $(aws --version 2>&1 || echo 'AWS CLI not available')"
        echo "üìÅ Working Directory: $(pwd)"
        echo "::endgroup::"
        
        # Set environment variables with validation
        CLOUDFORMATION_DIR="${{ inputs.cloudformation-dir }}"
        TEMPLATE_FILE="${{ inputs.template-file }}"
        TEMPLATE_PATH="${CLOUDFORMATION_DIR}/${TEMPLATE_FILE}"
        
        echo "::group::üìã Configuration"
        echo "üîç CloudFormation Directory: ${CLOUDFORMATION_DIR}"
        echo "üìÑ Template File: ${TEMPLATE_FILE}"
        echo "üìç Full Template Path: ${TEMPLATE_PATH}"
        echo "::endgroup::"
        
        echo "üîç Validating CloudFormation template: ${TEMPLATE_PATH}"
        
        # Validate input parameters
        if [[ -z "${CLOUDFORMATION_DIR}" ]]; then
          echo "::error::CloudFormation directory is empty or not specified"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=CloudFormation directory is empty" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        if [[ -z "${TEMPLATE_FILE}" ]]; then
          echo "::error::Template file name is empty or not specified"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file name is empty" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Check if CloudFormation directory exists
        if [[ ! -d "${CLOUDFORMATION_DIR}" ]]; then
          echo "::error::CloudFormation directory does not exist: ${CLOUDFORMATION_DIR}"
          echo "üìÅ Current directory contents:"
          ls -la . || echo "Unable to list current directory"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=CloudFormation directory not found: ${CLOUDFORMATION_DIR}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Check if template file exists
        if [[ ! -f "${TEMPLATE_PATH}" ]]; then
          echo "::error::Template file not found: ${TEMPLATE_PATH}"
          echo "üìÅ Available files in ${CLOUDFORMATION_DIR}:"
          ls -la "${CLOUDFORMATION_DIR}" 2>&1 || echo "Unable to list directory contents"
          
          # Try to find similar files
          echo "üîç Looking for similar template files..."
          find "${CLOUDFORMATION_DIR}" -maxdepth 2 -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) 2>/dev/null | head -10 || echo "No template files found"
          
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file not found: ${TEMPLATE_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "‚úÖ Template file found: ${TEMPLATE_PATH}"
        
        # Validate file is readable and not empty
        if [[ ! -r "${TEMPLATE_PATH}" ]]; then
          echo "::error::Template file is not readable: ${TEMPLATE_PATH}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file is not readable" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        FILE_SIZE=$(stat -f%z "${TEMPLATE_PATH}" 2>/dev/null || stat -c%s "${TEMPLATE_PATH}" 2>/dev/null || echo "0")
        if [[ "${FILE_SIZE}" -eq 0 ]]; then
          echo "::error::Template file is empty: ${TEMPLATE_PATH}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Template file is empty" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "üìè Template file size: ${FILE_SIZE} bytes"
        
        # Create output directory for validation results
        mkdir -p validation-output
        
        # Log template file preview for debugging
        echo "::group::üìÑ Template File Preview (first 10 lines)"
        head -10 "${TEMPLATE_PATH}" 2>/dev/null || echo "Unable to preview template file"
        echo "::endgroup::"
        
        # Validate template using AWS CLI with comprehensive error handling
        echo "üîÑ Running AWS CloudFormation template validation..."
        echo "‚è±Ô∏è Validation started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Function to perform AWS CLI validation with retry logic
        validate_template_with_retry() {
          local attempt=1
          local max_attempts=3
          local retry_delay=5
          
          while [[ $attempt -le $max_attempts ]]; do
            echo "üîÑ Validation attempt ${attempt}/${max_attempts}"
            
            # Set timeout for the AWS CLI command
            if timeout 300 aws cloudformation validate-template \
              --template-body "file://${TEMPLATE_PATH}" \
              --region "${{ inputs.aws-region }}" \
              --output json > validation-output/main-template-validation.json 2> validation-output/main-template-errors.log; then
              
              echo "‚úÖ Template validation successful on attempt ${attempt}!"
              return 0
            else
              local exit_code=$?
              echo "‚ùå Validation attempt ${attempt} failed with exit code: ${exit_code}"
              
              # Log error details for this attempt
              if [[ -f validation-output/main-template-errors.log ]]; then
                echo "::group::üîç Error details for attempt ${attempt}"
                cat validation-output/main-template-errors.log
                echo "::endgroup::"
                
                # Check for specific error types that shouldn't be retried
                if grep -q "ValidationError" validation-output/main-template-errors.log; then
                  echo "üö´ Template syntax error detected - not retrying"
                  return $exit_code
                fi
                
                if grep -q "AccessDenied\|UnauthorizedOperation\|InvalidUserID.NotFound" validation-output/main-template-errors.log; then
                  echo "üö´ Authentication/authorization error detected - not retrying"
                  return $exit_code
                fi
              fi
              
              if [[ $attempt -lt $max_attempts ]]; then
                echo "‚è≥ Waiting ${retry_delay} seconds before retry..."
                sleep $retry_delay
                retry_delay=$((retry_delay * 2))  # Exponential backoff
              fi
              
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå All validation attempts failed"
          return 1
        }
        
        # Execute validation with retry logic
        if validate_template_with_retry; then
          echo "‚è±Ô∏è Validation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Validate that the output file was created and is valid JSON
          if [[ ! -f validation-output/main-template-validation.json ]]; then
            echo "::error::Validation output file was not created"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error=Validation output file missing" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Validate JSON output
          if ! jq empty validation-output/main-template-validation.json 2>/dev/null; then
            echo "::error::Validation output is not valid JSON"
            echo "üîç Raw output content:"
            cat validation-output/main-template-validation.json 2>/dev/null || echo "Unable to read output file"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error=Invalid JSON in validation output" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Display template capabilities and parameters using jq
          echo "::group::üìã Template Details"
          
          # Extract and display description
          DESCRIPTION=$(jq -r '.Description // "No description provided"' validation-output/main-template-validation.json)
          echo "üìù Description: ${DESCRIPTION}"
          
          # Extract and display capabilities
          CAPABILITIES=$(jq -r '.Capabilities[]? // empty' validation-output/main-template-validation.json)
          if [[ -n "${CAPABILITIES}" ]]; then
            echo "üîê Required Capabilities:"
            echo "${CAPABILITIES}" | while read -r capability; do
              echo "  - ${capability}"
            done
            
            # Display capabilities reason if available
            CAPABILITIES_REASON=$(jq -r '.CapabilitiesReason // empty' validation-output/main-template-validation.json)
            if [[ -n "${CAPABILITIES_REASON}" ]]; then
              echo "üí° Reason: ${CAPABILITIES_REASON}"
            fi
          else
            echo "üîê No special capabilities required"
          fi
          
          # Extract and display parameters
          PARAMETERS=$(jq -r '.Parameters[]? // empty' validation-output/main-template-validation.json)
          if [[ -n "${PARAMETERS}" ]]; then
            echo "üìù Template Parameters:"
            jq -r '.Parameters[] | "  - \(.ParameterKey): \(.Description // "No description") (Default: \(.DefaultValue // "None"))"' validation-output/main-template-validation.json
            
            # Count parameters
            PARAM_COUNT=$(jq '.Parameters | length' validation-output/main-template-validation.json)
            echo "üìä Total parameters: ${PARAM_COUNT}"
          else
            echo "üìù No parameters defined in template"
          fi
          
          # Extract and display metadata if available
          METADATA=$(jq -r '.Metadata // empty' validation-output/main-template-validation.json)
          if [[ -n "${METADATA}" ]] && [[ "${METADATA}" != "null" ]]; then
            echo "üè∑Ô∏è Template includes metadata"
          fi
          
          echo "::endgroup::"
          
          # Set success outputs
          echo "result=success" >> $GITHUB_OUTPUT
          echo "template-path=${TEMPLATE_PATH}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          
        else
          echo "‚ùå Template validation failed after all retry attempts!"
          echo "‚è±Ô∏è Validation failed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Comprehensive error analysis and reporting
          echo "::group::üîç Detailed Error Analysis"
          
          if [[ -f validation-output/main-template-errors.log ]]; then
            echo "üìÑ Raw error output:"
            cat validation-output/main-template-errors.log
            echo ""
            
            # Extract and categorize different types of errors
            ERROR_CONTENT=$(cat validation-output/main-template-errors.log)
            
            # Try multiple methods to extract error messages
            ERROR_MESSAGE=""
            
            # Method 1: Extract JSON error message
            JSON_ERROR=$(echo "${ERROR_CONTENT}" | grep -o '"message":"[^"]*"' | sed 's/"message":"\([^"]*\)"/\1/' | head -1)
            if [[ -n "${JSON_ERROR}" ]]; then
              ERROR_MESSAGE="${JSON_ERROR}"
            fi
            
            # Method 2: Extract ValidationError
            if [[ -z "${ERROR_MESSAGE}" ]]; then
              VALIDATION_ERROR=$(echo "${ERROR_CONTENT}" | grep -o "ValidationError[^:]*: [^\\n]*" | head -1)
              if [[ -n "${VALIDATION_ERROR}" ]]; then
                ERROR_MESSAGE="${VALIDATION_ERROR}"
              fi
            fi
            
            # Method 3: Extract any error line
            if [[ -z "${ERROR_MESSAGE}" ]]; then
              ERROR_MESSAGE=$(echo "${ERROR_CONTENT}" | grep -i "error" | head -1)
            fi
            
            # Method 4: Use first non-empty line
            if [[ -z "${ERROR_MESSAGE}" ]]; then
              ERROR_MESSAGE=$(echo "${ERROR_CONTENT}" | grep -v "^$" | head -1)
            fi
            
            # Categorize error types for better user guidance
            if echo "${ERROR_CONTENT}" | grep -q "ValidationError"; then
              echo "üè∑Ô∏è Error Type: Template Syntax/Structure Error"
              echo "üí° Suggestion: Check your CloudFormation template syntax and structure"
            elif echo "${ERROR_CONTENT}" | grep -q "AccessDenied\|UnauthorizedOperation"; then
              echo "üè∑Ô∏è Error Type: AWS Authentication/Authorization Error"
              echo "üí° Suggestion: Check your AWS credentials and IAM permissions"
            elif echo "${ERROR_CONTENT}" | grep -q "InvalidUserID.NotFound"; then
              echo "üè∑Ô∏è Error Type: AWS Account/User Error"
              echo "üí° Suggestion: Verify your AWS account configuration"
            elif echo "${ERROR_CONTENT}" | grep -q "RequestLimitExceeded\|Throttling"; then
              echo "üè∑Ô∏è Error Type: AWS API Rate Limiting"
              echo "üí° Suggestion: The validation was rate limited, try again later"
            elif echo "${ERROR_CONTENT}" | grep -q "ServiceUnavailable\|InternalError"; then
              echo "üè∑Ô∏è Error Type: AWS Service Error"
              echo "üí° Suggestion: AWS CloudFormation service may be experiencing issues"
            else
              echo "üè∑Ô∏è Error Type: Unknown Error"
              echo "üí° Suggestion: Check the error details above for more information"
            fi
            
            # Create appropriate GitHub error annotation
            if [[ -n "${ERROR_MESSAGE}" ]]; then
              echo "::error title=CloudFormation Validation Failed::${ERROR_MESSAGE}"
            else
              echo "::error title=CloudFormation Validation Failed::Template validation failed. Check logs for details."
            fi
            
          else
            echo "‚ùå No error log file found"
            ERROR_MESSAGE="Template validation failed with no error details"
            echo "::error title=CloudFormation Validation Failed::${ERROR_MESSAGE}"
          fi
          
          echo "::endgroup::"
          
          # Set failure outputs
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "template-path=${TEMPLATE_PATH}" >> $GITHUB_OUTPUT
          echo "error=${ERROR_MESSAGE:-"Template validation failed"}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          
          exit 1
        fi

    - name: Validate nested CloudFormation templates
      id: nested-validation
      if: steps.main-validation.outputs.result == 'success'
      shell: bash
      env:
        # AWS CLI configuration for retries and timeouts
        AWS_MAX_ATTEMPTS: 3
        AWS_RETRY_MODE: adaptive
        AWS_CLI_READ_TIMEOUT: 300
        AWS_CLI_CONNECT_TIMEOUT: 60
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üîç Starting nested CloudFormation templates validation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üåç AWS Region: ${{ inputs.aws-region }}"
        echo "::endgroup::"
        
        # Set environment variables
        CLOUDFORMATION_DIR="${{ inputs.cloudformation-dir }}"
        NESTED_DIR="${CLOUDFORMATION_DIR}/nested-templates"
        
        echo "::group::üìã Configuration"
        echo "üîç CloudFormation Directory: ${CLOUDFORMATION_DIR}"
        echo "üìÅ Nested Templates Directory: ${NESTED_DIR}"
        echo "::endgroup::"
        
        echo "üîç Checking for nested templates in: ${NESTED_DIR}"
        
        # Check if nested templates directory exists
        if [[ ! -d "${NESTED_DIR}" ]]; then
          echo "‚è≠Ô∏è No nested templates directory found. Skipping nested template validation."
          echo "üí° To include nested template validation, create a 'nested-templates' directory in your CloudFormation directory"
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No nested templates directory found" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üìÅ Found nested templates directory: ${NESTED_DIR}"
        
        # Check directory permissions
        if [[ ! -r "${NESTED_DIR}" ]]; then
          echo "::error::Nested templates directory is not readable: ${NESTED_DIR}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "message=Nested templates directory is not readable" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Find all YAML and JSON files in nested directory
        echo "üîÑ Searching for CloudFormation templates..."
        echo "::group::üîç Template Discovery"
        
        # Use more robust find command with error handling
        NESTED_TEMPLATES=""
        if NESTED_TEMPLATES=$(find "${NESTED_DIR}" -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) 2>/dev/null); then
          echo "‚úÖ Template search completed successfully"
        else
          echo "‚ö†Ô∏è Warning: Error occurred during template search, but continuing..."
          NESTED_TEMPLATES=""
        fi
        
        # Additional search for hidden or unusual files
        echo "üìä Directory contents:"
        ls -la "${NESTED_DIR}" 2>/dev/null || echo "Unable to list directory contents"
        
        echo "::endgroup::"
        
        if [[ -z "${NESTED_TEMPLATES}" ]]; then
          echo "‚è≠Ô∏è No CloudFormation template files found in nested directory. Skipping validation."
          echo "üí° Supported file extensions: .yaml, .yml, .json"
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No template files found in nested directory" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üìã Found nested templates:"
        TEMPLATE_COUNT=0
        while IFS= read -r template; do
          [[ -z "${template}" ]] && continue
          echo "  - ${template}"
          ((TEMPLATE_COUNT++))
        done <<< "${NESTED_TEMPLATES}"
        
        echo "üìä Total templates to validate: ${TEMPLATE_COUNT}"
        
        # Create output directory for nested validation results
        mkdir -p validation-output/nested
        
        # Initialize validation tracking variables
        VALIDATION_SUCCESS=true
        FAILED_TEMPLATES=""
        VALIDATED_COUNT=0
        FAILED_COUNT=0
        SKIPPED_COUNT=0
        
        # Function to validate a single template with retry logic
        validate_nested_template() {
          local template_path="$1"
          local template_name=$(basename "${template_path}")
          local output_file="validation-output/nested/${template_name}-validation.json"
          local error_file="validation-output/nested/${template_name}-errors.log"
          local attempt=1
          local max_attempts=3
          local retry_delay=2
          
          echo "::group::üîç Validating ${template_name}"
          echo "üìÑ Template: ${template_path}"
          echo "üìè File size: $(stat -f%z "${template_path}" 2>/dev/null || stat -c%s "${template_path}" 2>/dev/null || echo "unknown") bytes"
          
          # Check if file is readable and not empty
          if [[ ! -r "${template_path}" ]]; then
            echo "::error::Template file is not readable: ${template_path}"
            echo "‚ùå ${template_name}: File not readable"
            echo "::endgroup::"
            return 1
          fi
          
          local file_size=$(stat -f%z "${template_path}" 2>/dev/null || stat -c%s "${template_path}" 2>/dev/null || echo "0")
          if [[ "${file_size}" -eq 0 ]]; then
            echo "::warning::Template file is empty: ${template_path}"
            echo "‚è≠Ô∏è ${template_name}: Skipping empty file"
            echo "::endgroup::"
            return 2  # Special return code for skipped files
          fi
          
          # Show file preview for debugging
          echo "üìÑ Template preview (first 5 lines):"
          head -5 "${template_path}" 2>/dev/null | sed 's/^/  /' || echo "  Unable to preview file"
          
          while [[ $attempt -le $max_attempts ]]; do
            echo "üîÑ Validation attempt ${attempt}/${max_attempts} for ${template_name}"
            
            # Clear previous attempt files
            rm -f "${output_file}" "${error_file}"
            
            if timeout 300 aws cloudformation validate-template \
              --template-body "file://${template_path}" \
              --region "${{ inputs.aws-region }}" \
              --output json > "${output_file}" 2> "${error_file}"; then
              
              echo "‚úÖ ${template_name}: Validation successful on attempt ${attempt}!"
              
              # Validate output file
              if [[ -f "${output_file}" ]] && jq empty "${output_file}" 2>/dev/null; then
                # Display basic template info
                local description=$(jq -r '.Description // "No description"' "${output_file}")
                echo "üìù Description: ${description}"
                
                # Show capabilities if any
                local capabilities=$(jq -r '.Capabilities[]? // empty' "${output_file}")
                if [[ -n "${capabilities}" ]]; then
                  echo "üîê Capabilities: $(echo "${capabilities}" | tr '\n' ', ' | sed 's/,$//')"
                fi
                
                # Show parameter count
                local param_count=$(jq '.Parameters | length' "${output_file}" 2>/dev/null || echo "0")
                echo "üìä Parameters: ${param_count}"
                
                echo "::endgroup::"
                return 0
              else
                echo "‚ö†Ô∏è Warning: Invalid output file generated, treating as failure"
                echo "::endgroup::"
                return 1
              fi
              
            else
              local exit_code=$?
              echo "‚ùå Validation attempt ${attempt} failed with exit code: ${exit_code}"
              
              # Analyze error for retry decision
              local should_retry=true
              if [[ -f "${error_file}" ]]; then
                local error_content=$(cat "${error_file}")
                
                # Don't retry on syntax errors or auth errors
                if echo "${error_content}" | grep -q "ValidationError\|AccessDenied\|UnauthorizedOperation\|InvalidUserID.NotFound"; then
                  should_retry=false
                fi
                
                echo "üîç Error preview:"
                head -2 "${error_file}" | sed 's/^/  /' || echo "  No error details available"
              fi
              
              if [[ $attempt -lt $max_attempts ]] && [[ "$should_retry" == "true" ]]; then
                echo "‚è≥ Waiting ${retry_delay} seconds before retry..."
                sleep $retry_delay
                retry_delay=$((retry_delay * 2))
              else
                if [[ "$should_retry" == "false" ]]; then
                  echo "üö´ Error type detected that should not be retried"
                fi
                break
              fi
              
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå ${template_name}: All validation attempts failed"
          echo "::endgroup::"
          return 1
        }
        
        # Validate each nested template
        echo "üîÑ Validating nested templates..."
        echo "‚è±Ô∏è Validation started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        while IFS= read -r template_path; do
          [[ -z "${template_path}" ]] && continue
          
          template_name=$(basename "${template_path}")
          
          # Call validation function
          if validate_nested_template "${template_path}"; then
            ((VALIDATED_COUNT++))
          elif [[ $? -eq 2 ]]; then
            # File was skipped (empty)
            ((SKIPPED_COUNT++))
          else
            # Validation failed
            VALIDATION_SUCCESS=false
            FAILED_TEMPLATES="${FAILED_TEMPLATES}${template_name} "
            ((FAILED_COUNT++))
            
            # Enhanced error reporting
            error_file="validation-output/nested/${template_name}-errors.log"
            if [[ -f "${error_file}" ]]; then
              echo "::group::üîç Detailed Error Analysis for ${template_name}"
              
              local error_content=$(cat "${error_file}")
              
              # Extract and categorize error message
              local error_message=""
              
              # Try multiple extraction methods
              if error_message=$(echo "${error_content}" | grep -o '"message":"[^"]*"' | sed 's/"message":"\([^"]*\)"/\1/' | head -1); then
                echo "üìÑ Extracted error: ${error_message}"
              elif error_message=$(echo "${error_content}" | grep -o "ValidationError[^:]*: [^\\n]*" | head -1); then
                echo "üìÑ Validation error: ${error_message}"
              else
                error_message=$(echo "${error_content}" | grep -v "^$" | head -1)
                echo "üìÑ Raw error: ${error_message}"
              fi
              
              # Categorize error type
              if echo "${error_content}" | grep -q "ValidationError"; then
                echo "üè∑Ô∏è Error Type: Template Syntax/Structure Error"
                echo "::error title=Nested Template Syntax Error::${template_name}: ${error_message}"
              elif echo "${error_content}" | grep -q "AccessDenied\|UnauthorizedOperation"; then
                echo "üè∑Ô∏è Error Type: AWS Authentication/Authorization Error"
                echo "::error title=Nested Template Auth Error::${template_name}: ${error_message}"
              else
                echo "üè∑Ô∏è Error Type: Unknown Error"
                echo "::error title=Nested Template Validation Failed::${template_name}: ${error_message}"
              fi
              
              echo "üìÑ Full error log:"
              cat "${error_file}" | sed 's/^/  /'
              echo "::endgroup::"
            else
              echo "::error title=Nested Template Validation Failed::${template_name}: No error details available"
            fi
          fi
          
        done <<< "${NESTED_TEMPLATES}"
        
        echo "‚è±Ô∏è Validation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Generate comprehensive summary and set outputs
        echo ""
        echo "::group::üìä Nested Templates Validation Summary"
        echo "üìã Validation Results:"
        echo "  Total templates found: $((VALIDATED_COUNT + FAILED_COUNT + SKIPPED_COUNT))"
        echo "  Successfully validated: ${VALIDATED_COUNT}"
        echo "  Failed validation: ${FAILED_COUNT}"
        echo "  Skipped (empty files): ${SKIPPED_COUNT}"
        
        if [[ ${FAILED_COUNT} -gt 0 ]]; then
          echo "  Failed templates: ${FAILED_TEMPLATES}"
        fi
        echo "::endgroup::"
        
        if [[ "${VALIDATION_SUCCESS}" == "true" ]]; then
          if [[ ${VALIDATED_COUNT} -gt 0 ]]; then
            echo "‚úÖ All nested templates validated successfully!"
            echo "result=success" >> $GITHUB_OUTPUT
            echo "message=All ${VALIDATED_COUNT} nested templates validated successfully" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è No templates were validated (all were skipped)"
            echo "result=skipped" >> $GITHUB_OUTPUT
            echo "message=All nested templates were skipped (empty files)" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Some nested templates failed validation!"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "message=${FAILED_COUNT} nested templates failed validation" >> $GITHUB_OUTPUT
          echo "failed-templates=${FAILED_TEMPLATES}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Set common outputs
        echo "validated-count=${VALIDATED_COUNT}" >> $GITHUB_OUTPUT
        echo "failed-count=${FAILED_COUNT}" >> $GITHUB_OUTPUT
        echo "skipped-count=${SKIPPED_COUNT}" >> $GITHUB_OUTPUT
        echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

    - name: Validate parameters file
      id: parameters-validation
      if: steps.main-validation.outputs.result == 'success'
      shell: bash
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üîç Starting parameters file validation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üîß jq Version: $(jq --version 2>&1 || echo 'jq not available')"
        echo "::endgroup::"
        
        # Set environment variables with validation
        CLOUDFORMATION_DIR="${{ inputs.cloudformation-dir }}"
        PARAMETERS_FILE="${{ inputs.parameters-file }}"
        PARAMETERS_PATH="${CLOUDFORMATION_DIR}/${PARAMETERS_FILE}"
        
        echo "::group::üìã Configuration"
        echo "üîç CloudFormation Directory: ${CLOUDFORMATION_DIR}"
        echo "üìÑ Parameters File: ${PARAMETERS_FILE}"
        echo "üìç Full Parameters Path: ${PARAMETERS_PATH}"
        echo "::endgroup::"
        
        echo "üîç Checking for parameters file: ${PARAMETERS_PATH}"
        
        # Validate input parameters
        if [[ -z "${PARAMETERS_FILE}" ]]; then
          echo "‚è≠Ô∏è Parameters file name is empty. Skipping parameters validation."
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No parameters file specified" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Check if parameters file exists
        if [[ ! -f "${PARAMETERS_PATH}" ]]; then
          echo "‚è≠Ô∏è Parameters file not found. Skipping parameters validation."
          echo "üí° To include parameters validation, create a parameters file at: ${PARAMETERS_PATH}"
          
          # Show what files are available in the directory
          echo "üìÅ Available files in ${CLOUDFORMATION_DIR}:"
          ls -la "${CLOUDFORMATION_DIR}" 2>/dev/null | grep -E '\.(json|yaml|yml)$' || echo "  No JSON/YAML files found"
          
          echo "result=skipped" >> $GITHUB_OUTPUT
          echo "message=No parameters file found" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üìÅ Found parameters file: ${PARAMETERS_PATH}"
        
        # Validate file permissions and size
        if [[ ! -r "${PARAMETERS_PATH}" ]]; then
          echo "::error::Parameters file is not readable: ${PARAMETERS_PATH}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Parameters file is not readable" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        FILE_SIZE=$(stat -f%z "${PARAMETERS_PATH}" 2>/dev/null || stat -c%s "${PARAMETERS_PATH}" 2>/dev/null || echo "0")
        if [[ "${FILE_SIZE}" -eq 0 ]]; then
          echo "::error::Parameters file is empty: ${PARAMETERS_PATH}"
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Parameters file is empty" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "üìè Parameters file size: ${FILE_SIZE} bytes"
        
        # Create output directory for parameters validation results
        mkdir -p validation-output/parameters
        
        # Log file preview for debugging
        echo "::group::üìÑ Parameters File Preview"
        echo "üìÑ File content preview (first 10 lines):"
        head -10 "${PARAMETERS_PATH}" 2>/dev/null | sed 's/^/  /' || echo "  Unable to preview file"
        echo "::endgroup::"
        
        # Validate JSON syntax using jq with comprehensive error handling
        echo "üîÑ Validating JSON syntax..."
        echo "‚è±Ô∏è JSON validation started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Function to validate JSON with detailed error reporting
        validate_json_syntax() {
          local error_file="validation-output/parameters/json-syntax-errors.log"
          
          echo "::group::üîç JSON Syntax Validation"
          
          # Clear previous error log
          rm -f "${error_file}"
          
          # Test JSON syntax with jq
          if jq empty "${PARAMETERS_PATH}" 2> "${error_file}"; then
            echo "‚úÖ JSON syntax is valid"
            echo "::endgroup::"
            return 0
          else
            echo "‚ùå JSON syntax validation failed!"
            
            # Analyze and report JSON errors
            if [[ -f "${error_file}" ]]; then
              echo "üîç JSON Syntax Error Details:"
              local error_content=$(cat "${error_file}")
              echo "${error_content}"
              
              # Extract line and column information if available
              local line_info=""
              if line_info=$(echo "${error_content}" | grep -o "line [0-9]*" | head -1); then
                echo "üìç Error location: ${line_info}"
              fi
              
              local column_info=""
              if column_info=$(echo "${error_content}" | grep -o "column [0-9]*" | head -1); then
                echo "üìç Error position: ${column_info}"
              fi
              
              # Extract the main error message
              local error_message=""
              if error_message=$(echo "${error_content}" | head -1); then
                echo "üìÑ Main error: ${error_message}"
                echo "::error title=Parameters JSON Syntax Error::${error_message}"
              else
                echo "::error title=Parameters JSON Syntax Error::Invalid JSON syntax in parameters file"
              fi
              
              # Show context around the error if line number is available
              if [[ -n "${line_info}" ]]; then
                local line_num=$(echo "${line_info}" | grep -o "[0-9]*")
                if [[ -n "${line_num}" ]] && [[ "${line_num}" -gt 0 ]]; then
                  echo "üìÑ Context around error (lines $((line_num-2)) to $((line_num+2))):"
                  sed -n "$((line_num-2)),$((line_num+2))p" "${PARAMETERS_PATH}" 2>/dev/null | nl -ba | sed 's/^/  /' || echo "  Unable to show context"
                fi
              fi
              
            else
              echo "‚ùå No error details available"
              echo "::error title=Parameters JSON Syntax Error::JSON syntax validation failed with no error details"
            fi
            
            echo "::endgroup::"
            return 1
          fi
        }
        
        # Execute JSON validation
        if ! validate_json_syntax; then
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Invalid JSON syntax" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Validate structure - ensure it's an array format with ParameterKey/ParameterValue objects
        echo "üîÑ Validating parameters structure..."
        echo "‚è±Ô∏è Structure validation started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        echo "::group::üîç Structure Validation"
        
        # Check if the root is an array
        echo "üìã Checking if root element is an array..."
        if ! jq -e 'type == "array"' "${PARAMETERS_PATH}" > /dev/null 2>&1; then
          echo "‚ùå Parameters file structure validation failed!"
          echo "üîç Structure Error: Parameters file must be a JSON array"
          echo ""
          echo "üìñ Expected format:"
          echo '  [{"ParameterKey": "key1", "ParameterValue": "value1"}, ...]'
          echo ""
          echo "üìÑ Current root type:"
          local current_type=$(jq -r 'type' "${PARAMETERS_PATH}" 2>/dev/null || echo "unknown")
          echo "  ${current_type}"
          
          if [[ "${current_type}" == "object" ]]; then
            echo "üí° Hint: Your file appears to be a JSON object. Convert it to an array format."
            echo "üìÑ Current structure preview:"
            jq -r 'keys[]' "${PARAMETERS_PATH}" 2>/dev/null | head -5 | sed 's/^/    /' || echo "    Unable to show keys"
          fi
          
          echo "::error title=Parameters Structure Error::Parameters file must be a JSON array of parameter objects"
          echo "::endgroup::"
          
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "error=Parameters file must be a JSON array" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "‚úÖ Root element is an array"
        
        # Check if array is empty
        PARAM_COUNT=$(jq 'length' "${PARAMETERS_PATH}")
        echo "üìä Array length: ${PARAM_COUNT}"
        
        if [[ "${PARAM_COUNT}" -eq 0 ]]; then
          echo "‚ö†Ô∏è Parameters file is an empty array"
          echo "‚úÖ Structure is valid but no parameters defined"
          echo "::endgroup::"
          
          echo "result=success" >> $GITHUB_OUTPUT
          echo "parameters-count=0" >> $GITHUB_OUTPUT
          echo "message=Parameters file is valid but empty" >> $GITHUB_OUTPUT
          echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
          echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Validate each parameter object structure
        echo "üîÑ Validating individual parameter objects..."
        
        # Create comprehensive structure validation with detailed error reporting
        STRUCTURE_ERRORS=""
        STRUCTURE_WARNINGS=""
        
        # Check if all elements are objects with required keys
        if STRUCTURE_ERRORS=$(jq -r '
          to_entries[] | 
          select(
            (.value | type != "object") or 
            (.value | has("ParameterKey") | not) or 
            (.value | has("ParameterValue") | not) or
            (.value.ParameterKey | type != "string") or
            (.value.ParameterValue | type != "string")
          ) | 
          "Parameter at index \(.key): \(
            if (.value | type != "object") then "must be an object (currently: \(.value | type))"
            elif (.value | has("ParameterKey") | not) then "missing required ParameterKey field"
            elif (.value | has("ParameterValue") | not) then "missing required ParameterValue field"
            elif (.value.ParameterKey | type != "string") then "ParameterKey must be a string (currently: \(.value.ParameterKey | type))"
            elif (.value.ParameterValue | type != "string") then "ParameterValue must be a string (currently: \(.value.ParameterValue | type))"
            else "unknown structural error"
            end
          )"
        ' "${PARAMETERS_PATH}" 2>/dev/null); then
          
          if [[ -n "${STRUCTURE_ERRORS}" ]]; then
            echo "‚ùå Parameters structure validation failed!"
            echo "üîç Structure Validation Errors:"
            echo "${STRUCTURE_ERRORS}"
            echo ""
            echo "üìñ Expected format for each parameter:"
            echo '  {"ParameterKey": "string", "ParameterValue": "string"}'
            echo ""
            echo "üìÑ Example of valid parameters file:"
            cat << EOF
              [
                {"ParameterKey": "Environment", "ParameterValue": "production"},
                {"ParameterKey": "InstanceType", "ParameterValue": "t3.micro"}
              ]
              EOF
                        
            # Create GitHub error annotations for each structure error
            local error_count=0
            while IFS= read -r error_line; do
              [[ -z "${error_line}" ]] && continue
              echo "::error title=Parameter Structure Error::${error_line}"
              ((error_count++))
            done <<< "${STRUCTURE_ERRORS}"
            
            echo "üìä Total structure errors: ${error_count}"
            echo "::endgroup::"
            
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error=Invalid parameter object structure (${error_count} errors)" >> $GITHUB_OUTPUT
            echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
            echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
            exit 1
          fi
        else
          echo "‚ö†Ô∏è Warning: Error occurred during structure validation, but continuing..."
        fi
        
        echo "‚úÖ Parameters structure validation successful!"
        echo "::endgroup::"
        
        # Advanced validation and analysis
        echo "::group::üìä Parameters Analysis"
        
        # Display parameter keys and values on successful validation
        echo "üìã Parameters Summary:"
        echo "  Total parameters: ${PARAM_COUNT}"
        echo ""
        
        # Extract and display all parameters with their keys and values
        echo "üìù Parameter Details:"
        if jq -r '.[] | "  üîë \(.ParameterKey): \(.ParameterValue)"' "${PARAMETERS_PATH}" > validation-output/parameters/parameters-summary.txt 2>/dev/null; then
          cat validation-output/parameters/parameters-summary.txt
        else
          echo "  ‚ö†Ô∏è Unable to extract parameter details"
        fi
        
        # Create processed JSON for potential use by other steps
        if jq '[.[] | {key: .ParameterKey, value: .ParameterValue}]' "${PARAMETERS_PATH}" > validation-output/parameters/parameters-processed.json 2>/dev/null; then
          echo "üìÑ Processed parameters saved to validation-output/parameters/parameters-processed.json"
        fi
        
        # Check for duplicate parameter keys
        echo "üîç Checking for duplicate parameter keys..."
        DUPLICATE_KEYS=""
        if DUPLICATE_KEYS=$(jq -r '[.[].ParameterKey] | group_by(.) | map(select(length > 1)) | flatten | unique | .[]?' "${PARAMETERS_PATH}" 2>/dev/null); then
          if [[ -n "${DUPLICATE_KEYS}" ]]; then
            echo ""
            echo "‚ö†Ô∏è Warning: Duplicate parameter keys found:"
            local dup_count=0
            while IFS= read -r dup_key; do
              [[ -z "${dup_key}" ]] && continue
              echo "  - ${dup_key}"
              ((dup_count++))
            done <<< "${DUPLICATE_KEYS}"
            
            local dup_keys_list=$(echo "${DUPLICATE_KEYS}" | tr '\n' ', ' | sed 's/,$//')
            echo "::warning title=Duplicate Parameter Keys::Found ${dup_count} duplicate parameter keys: ${dup_keys_list}"
          else
            echo "‚úÖ No duplicate parameter keys found"
          fi
        else
          echo "‚ö†Ô∏è Unable to check for duplicate keys"
        fi
        
        # Check for empty parameter values
        echo "üîç Checking for empty parameter values..."
        EMPTY_VALUES=""
        if EMPTY_VALUES=$(jq -r '.[] | select(.ParameterValue == "") | .ParameterKey' "${PARAMETERS_PATH}" 2>/dev/null); then
          if [[ -n "${EMPTY_VALUES}" ]]; then
            echo "‚ö†Ô∏è Warning: Parameters with empty values found:"
            while IFS= read -r empty_key; do
              [[ -z "${empty_key}" ]] && continue
              echo "  - ${empty_key}"
            done <<< "${EMPTY_VALUES}"
            
            local empty_keys_list=$(echo "${EMPTY_VALUES}" | tr '\n' ', ' | sed 's/,$//')
            echo "::warning title=Empty Parameter Values::Parameters with empty values: ${empty_keys_list}"
          else
            echo "‚úÖ No empty parameter values found"
          fi
        fi
        
        # Generate parameter statistics
        echo "üìä Parameter Statistics:"
        local avg_key_length=$(jq -r '[.[].ParameterKey | length] | add / length | floor' "${PARAMETERS_PATH}" 2>/dev/null || echo "unknown")
        local avg_value_length=$(jq -r '[.[].ParameterValue | length] | add / length | floor' "${PARAMETERS_PATH}" 2>/dev/null || echo "unknown")
        echo "  Average key length: ${avg_key_length} characters"
        echo "  Average value length: ${avg_value_length} characters"
        
        echo "::endgroup::"
        
        echo "‚è±Ô∏è Parameters validation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Set success outputs
        echo "result=success" >> $GITHUB_OUTPUT
        echo "parameters-count=${PARAM_COUNT}" >> $GITHUB_OUTPUT
        echo "parameters-path=${PARAMETERS_PATH}" >> $GITHUB_OUTPUT
        echo "message=${PARAM_COUNT} parameters validated successfully" >> $GITHUB_OUTPUT
        echo "validation-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
        
        # Export parameter keys for potential use in summary
        PARAM_KEYS=""
        if PARAM_KEYS=$(jq -r '[.[].ParameterKey] | join(", ")' "${PARAMETERS_PATH}" 2>/dev/null); then
          echo "parameter-keys=${PARAM_KEYS}" >> $GITHUB_OUTPUT
        else
          echo "parameter-keys=" >> $GITHUB_OUTPUT
        fi

    - name: Generate validation summary
      id: summary
      if: always()
      shell: bash
      run: |
        set -euo pipefail
        
        # Enable detailed logging
        echo "::group::üîß Debug Information"
        echo "üìä Starting validation summary generation"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo "üîß Summary generation always runs regardless of previous step results"
        echo "::endgroup::"
        
        echo "üìä Generating comprehensive validation summary..."
        
        # Read validation results from previous steps with error handling
        echo "::group::üìã Collecting Validation Results"
        
        MAIN_RESULT="${{ steps.main-validation.outputs.result }}"
        NESTED_RESULT="${{ steps.nested-validation.outputs.result }}"
        PARAMETERS_RESULT="${{ steps.parameters-validation.outputs.result }}"
        
        echo "üîç Main template result: ${MAIN_RESULT:-"not available"}"
        echo "üîç Nested templates result: ${NESTED_RESULT:-"not available"}"
        echo "üîç Parameters result: ${PARAMETERS_RESULT:-"not available"}"
        
        # Get file paths with fallbacks
        TEMPLATE_PATH="${{ steps.main-validation.outputs.template-path }}"
        PARAMETERS_PATH="${{ steps.parameters-validation.outputs.parameters-path }}"
        
        echo "üìÑ Template path: ${TEMPLATE_PATH:-"not available"}"
        echo "üìÑ Parameters path: ${PARAMETERS_PATH:-"not available"}"
        
        # Get timestamps for tracking
        MAIN_TIMESTAMP="${{ steps.main-validation.outputs.validation-timestamp }}"
        NESTED_TIMESTAMP="${{ steps.nested-validation.outputs.validation-timestamp }}"
        PARAMETERS_TIMESTAMP="${{ steps.parameters-validation.outputs.validation-timestamp }}"
        
        echo "‚è±Ô∏è Main validation timestamp: ${MAIN_TIMESTAMP:-"not available"}"
        echo "‚è±Ô∏è Nested validation timestamp: ${NESTED_TIMESTAMP:-"not available"}"
        echo "‚è±Ô∏è Parameters validation timestamp: ${PARAMETERS_TIMESTAMP:-"not available"}"
        
        echo "::endgroup::"
        
        # Determine overall validation result with comprehensive logic
        echo "::group::üéØ Determining Overall Result"
        
        OVERALL_RESULT="success"
        FAILURE_REASONS=()
        
        # Check each validation step
        if [[ "${MAIN_RESULT}" == "failure" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Main template validation failed")
          echo "‚ùå Main template validation failed"
        elif [[ "${MAIN_RESULT}" == "success" ]]; then
          echo "‚úÖ Main template validation succeeded"
        elif [[ -z "${MAIN_RESULT}" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Main template validation did not complete")
          echo "‚ùì Main template validation did not complete"
        fi
        
        if [[ "${NESTED_RESULT}" == "failure" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Nested templates validation failed")
          echo "‚ùå Nested templates validation failed"
        elif [[ "${NESTED_RESULT}" == "success" ]]; then
          echo "‚úÖ Nested templates validation succeeded"
        elif [[ "${NESTED_RESULT}" == "skipped" ]]; then
          echo "‚è≠Ô∏è Nested templates validation was skipped"
        fi
        
        if [[ "${PARAMETERS_RESULT}" == "failure" ]]; then
          OVERALL_RESULT="failure"
          FAILURE_REASONS+=("Parameters validation failed")
          echo "‚ùå Parameters validation failed"
        elif [[ "${PARAMETERS_RESULT}" == "success" ]]; then
          echo "‚úÖ Parameters validation succeeded"
        elif [[ "${PARAMETERS_RESULT}" == "skipped" ]]; then
          echo "‚è≠Ô∏è Parameters validation was skipped"
        fi
        
        echo "üéØ Overall result: ${OVERALL_RESULT}"
        if [[ ${#FAILURE_REASONS[@]} -gt 0 ]]; then
          echo "üìã Failure reasons:"
          for reason in "${FAILURE_REASONS[@]}"; do
            echo "  - ${reason}"
          done
        fi
        
        echo "::endgroup::"
        
        # Generate status indicators with error handling
        get_status_indicator() {
          case "$1" in
            "success") echo "‚úÖ" ;;
            "failure") echo "‚ùå" ;;
            "skipped") echo "‚è≠Ô∏è" ;;
            "") echo "‚ùì" ;;
            *) echo "‚ùì" ;;
          esac
        }
        
        MAIN_ICON=$(get_status_indicator "${MAIN_RESULT}")
        NESTED_ICON=$(get_status_indicator "${NESTED_RESULT}")
        PARAMETERS_ICON=$(get_status_indicator "${PARAMETERS_RESULT}")
        OVERALL_ICON=$(get_status_indicator "${OVERALL_RESULT}")
        
        echo "üé® Status icons: Main=${MAIN_ICON}, Nested=${NESTED_ICON}, Parameters=${PARAMETERS_ICON}, Overall=${OVERALL_ICON}"
        
        # Validate that GITHUB_STEP_SUMMARY is available
        if [[ -z "${GITHUB_STEP_SUMMARY:-}" ]]; then
          echo "::warning::GITHUB_STEP_SUMMARY environment variable is not set, summary will not be displayed"
          echo "üìÑ Summary would have been written to GitHub step summary"
        else
          echo "üìù Writing summary to: ${GITHUB_STEP_SUMMARY}"
        fi
        
        # Create comprehensive markdown summary for GitHub step summary
        echo "::group::üìù Generating Markdown Summary"
        
        # Function to safely write to step summary
        write_to_summary() {
          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            cat >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Summary content (would be written to GitHub step summary):"
            cat
          fi
        }
        
        # Generate the main summary
        write_to_summary << EOF
          # ${OVERALL_ICON} CloudFormation Validation Summary

          ## Overall Result: **${OVERALL_RESULT^^}**

          $(if [[ ${#FAILURE_REASONS[@]} -gt 0 ]]; then
            echo "### ‚ùå Failure Summary"
            for reason in "${FAILURE_REASONS[@]}"; do
              echo "- ${reason}"
            done
            echo ""
          fi)

          | Validation Type | Status | Result | Details |
          |---|---|---|---|
          | **Main Template** | ${MAIN_ICON} | **${MAIN_RESULT^^}** | \`${TEMPLATE_PATH:-"N/A"}\` |
          | **Nested Templates** | ${NESTED_ICON} | **${NESTED_RESULT^^}** | ${{ steps.nested-validation.outputs.message || 'N/A' }} |
          | **Parameters File** | ${PARAMETERS_ICON} | **${PARAMETERS_RESULT^^}** | \`${PARAMETERS_PATH:-"N/A"}\` |

          ---

          ## Validation Details

          ### ${MAIN_ICON} Main Template Validation
          - **File**: \`${TEMPLATE_PATH:-"Not specified"}\`
          - **Status**: ${MAIN_RESULT^^}
          $(if [[ -n "${MAIN_TIMESTAMP}" ]]; then echo "- **Timestamp**: ${MAIN_TIMESTAMP}"; fi)
          EOF
                  
                  # Add main template error details if failed
                  if [[ "${MAIN_RESULT}" == "failure" ]]; then
                    MAIN_ERROR="${{ steps.main-validation.outputs.error }}"
                    write_to_summary << EOF
          - **Error**: ${MAIN_ERROR:-"Unknown error"}
          EOF
        fi
        
        # Add nested templates details with comprehensive information
        write_to_summary << EOF

        ### ${NESTED_ICON} Nested Templates Validation
        - **Status**: ${NESTED_RESULT^^}
        $(if [[ -n "${NESTED_TIMESTAMP}" ]]; then echo "- **Timestamp**: ${NESTED_TIMESTAMP}"; fi)
        EOF
                
                if [[ "${NESTED_RESULT}" == "success" ]]; then
                  VALIDATED_COUNT="${{ steps.nested-validation.outputs.validated-count }}"
                  SKIPPED_COUNT="${{ steps.nested-validation.outputs.skipped-count }}"
                  write_to_summary << EOF
        - **Templates Validated**: ${VALIDATED_COUNT:-"0"}
        $(if [[ -n "${SKIPPED_COUNT}" ]] && [[ "${SKIPPED_COUNT}" != "0" ]]; then echo "- **Templates Skipped**: ${SKIPPED_COUNT}"; fi)
        - **Result**: All nested templates validated successfully
        EOF
                elif [[ "${NESTED_RESULT}" == "failure" ]]; then
                  VALIDATED_COUNT="${{ steps.nested-validation.outputs.validated-count }}"
                  FAILED_COUNT="${{ steps.nested-validation.outputs.failed-count }}"
                  SKIPPED_COUNT="${{ steps.nested-validation.outputs.skipped-count }}"
                  FAILED_TEMPLATES="${{ steps.nested-validation.outputs.failed-templates }}"
                  write_to_summary << EOF
        - **Templates Validated**: ${VALIDATED_COUNT:-"0"}
        - **Templates Failed**: ${FAILED_COUNT:-"0"}
        $(if [[ -n "${SKIPPED_COUNT}" ]] && [[ "${SKIPPED_COUNT}" != "0" ]]; then echo "- **Templates Skipped**: ${SKIPPED_COUNT}"; fi)
        - **Failed Templates**: ${FAILED_TEMPLATES:-"Unknown"}
        EOF
                else
                  NESTED_MESSAGE="${{ steps.nested-validation.outputs.message }}"
                  write_to_summary << EOF
        - **Result**: ${NESTED_MESSAGE:-"Nested templates validation was skipped"}
        EOF
                fi
                
                # Add parameters file details with comprehensive information
                write_to_summary << EOF

        ### ${PARAMETERS_ICON} Parameters File Validation
        - **File**: \`${PARAMETERS_PATH:-"Not specified"}\`
        - **Status**: ${PARAMETERS_RESULT^^}
        $(if [[ -n "${PARAMETERS_TIMESTAMP}" ]]; then echo "- **Timestamp**: ${PARAMETERS_TIMESTAMP}"; fi)
        EOF
                
                if [[ "${PARAMETERS_RESULT}" == "success" ]]; then
                  PARAM_COUNT="${{ steps.parameters-validation.outputs.parameters-count }}"
                  PARAM_KEYS="${{ steps.parameters-validation.outputs.parameter-keys }}"
                  write_to_summary << EOF
        - **Parameters Count**: ${PARAM_COUNT:-"0"}
        EOF
                  if [[ -n "${PARAM_KEYS}" ]] && [[ "${PARAM_KEYS}" != "" ]]; then
                    # Truncate parameter keys if too long for summary
                    if [[ ${#PARAM_KEYS} -gt 200 ]]; then
                      TRUNCATED_KEYS="${PARAM_KEYS:0:200}..."
                      write_to_summary << EOF
        - **Parameter Keys**: ${TRUNCATED_KEYS}
        EOF
                    else
                      write_to_summary << EOF
        - **Parameter Keys**: ${PARAM_KEYS}
        EOF
                    fi
                  fi
                elif [[ "${PARAMETERS_RESULT}" == "failure" ]]; then
                  PARAM_ERROR="${{ steps.parameters-validation.outputs.error }}"
                  write_to_summary << EOF
        - **Error**: ${PARAM_ERROR:-"Unknown error"}
        EOF
                else
                  PARAM_MESSAGE="${{ steps.parameters-validation.outputs.message }}"
                  write_to_summary << EOF
        - **Result**: ${PARAM_MESSAGE:-"Parameters validation was skipped"}
        EOF
                fi
                
                # Add comprehensive footer with artifact and configuration information
                write_to_summary << EOF

        ---

        ## üìÅ Artifacts

        Detailed validation results and logs have been uploaded as artifacts:
        - **Artifact Name**: \`cloudformation-validation-results-${{ github.run_id }}\`
        - **Retention**: 30 days
        - **Contents**: Validation output files, error logs, and detailed results

        ## üîß Action Configuration

        | Input | Value |
        |---|---|
        | **CloudFormation Directory** | \`${{ inputs.cloudformation-dir }}\` |
        | **Template File** | \`${{ inputs.template-file }}\` |
        | **Parameters File** | \`${{ inputs.parameters-file }}\` |
        | **AWS Region** | \`${{ inputs.aws-region }}\` |
        | **AWS Role ARN** | \`${{ inputs.aws-role-arn }}\` |

        ## üìä Execution Summary

        - **Workflow Run ID**: ${{ github.run_id }}
        - **Summary Generated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        - **Repository**: ${{ github.repository }}
        - **Branch/Ref**: ${{ github.ref }}

        $(if [[ "${OVERALL_RESULT}" == "failure" ]]; then
          echo "## üîß Troubleshooting"
          echo ""
          echo "The validation failed. Check the detailed logs above and the uploaded artifacts for more information."
          echo ""
          echo "### Common Issues:"
          echo "- **Template Syntax Errors**: Check your CloudFormation template syntax"
          echo "- **AWS Authentication**: Verify your AWS credentials and IAM permissions"
          echo "- **File Paths**: Ensure template and parameter files exist at the specified paths"
          echo "- **JSON Format**: Verify parameters file is valid JSON with correct structure"
        fi)
        EOF
        
        echo "‚úÖ Markdown summary generated successfully"
        echo "::endgroup::"
        
        # Set output for overall validation result with error handling
        echo "::group::üì§ Setting Outputs"
        
        if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
          echo "validation-result=${OVERALL_RESULT}" >> "$GITHUB_OUTPUT"
          echo "summary-timestamp=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> "$GITHUB_OUTPUT"
          echo "failure-count=${#FAILURE_REASONS[@]}" >> "$GITHUB_OUTPUT"
          
          # Export failure reasons as a comma-separated string
          if [[ ${#FAILURE_REASONS[@]} -gt 0 ]]; then
            IFS=','
            FAILURE_REASONS_STR="${FAILURE_REASONS[*]}"
            unset IFS
            echo "failure-reasons=${FAILURE_REASONS_STR}" >> "$GITHUB_OUTPUT"
          fi
          
          echo "‚úÖ Outputs set successfully"
        else
          echo "::warning::GITHUB_OUTPUT environment variable is not set"
          echo "üì§ Would have set validation-result=${OVERALL_RESULT}"
        fi
        
        echo "::endgroup::"
        
        # Final status report
        if [[ "${OVERALL_RESULT}" == "success" ]]; then
          echo "üéâ Validation summary generated successfully! All validations passed."
        else
          echo "üìã Validation summary generated successfully. Some validations failed - check details above."
        fi
        
        echo "‚è±Ô∏è Summary generation completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

    - name: Upload validation artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: cloudformation-validation-results-${{ github.run_id }}
        path: |
          validation-output/
        retention-days: 30
        compression-level: 6
        if-no-files-found: warn
      env:
        # Ensure artifact upload has proper timeout and retry behavior
        ACTIONS_STEP_DEBUG: ${{ runner.debug }}
      continue-on-error: true
      id: upload-artifacts
      
    - name: Verify artifact upload
      if: always()
      shell: bash
      run: |
        set -euo pipefail
        
        echo "::group::üìÅ Artifact Upload Verification"
        echo "üîç Verifying artifact upload status"
        echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        
        # Check if validation-output directory exists and has content
        if [[ -d "validation-output" ]]; then
          echo "‚úÖ Validation output directory exists"
          
          # Count files in validation-output
          FILE_COUNT=$(find validation-output -type f | wc -l | tr -d ' ')
          echo "üìä Total files in validation-output: ${FILE_COUNT}"
          
          if [[ "${FILE_COUNT}" -gt 0 ]]; then
            echo "üìã Validation output contents:"
            find validation-output -type f -exec ls -lh {} \; | sed 's/^/  /'
            
            # Calculate total size
            TOTAL_SIZE=$(du -sh validation-output 2>/dev/null | cut -f1 || echo "unknown")
            echo "üìè Total validation output size: ${TOTAL_SIZE}"
            
            # Show directory structure
            echo "üå≥ Directory structure:"
            tree validation-output 2>/dev/null || find validation-output -type d | sed 's/^/  /' || echo "  Unable to show directory structure"
            
          else
            echo "‚ö†Ô∏è Warning: Validation output directory is empty"
            echo "::warning::No validation output files were generated"
          fi
        else
          echo "‚ùå Validation output directory does not exist"
          echo "::warning::Validation output directory was not created"
        fi
        
        # Check artifact upload step result
        UPLOAD_OUTCOME="${{ steps.upload-artifacts.outcome }}"
        echo "üì§ Artifact upload outcome: ${UPLOAD_OUTCOME:-"not available"}"
        
        case "${UPLOAD_OUTCOME}" in
          "success")
            echo "‚úÖ Artifacts uploaded successfully"
            echo "üîó Artifact name: cloudformation-validation-results-${{ github.run_id }}"
            echo "‚è≥ Retention: 30 days"
            ;;
          "failure")
            echo "‚ùå Artifact upload failed"
            echo "::error::Failed to upload validation artifacts"
            ;;
          "skipped")
            echo "‚è≠Ô∏è Artifact upload was skipped"
            echo "::warning::Artifact upload was skipped"
            ;;
          *)
            echo "‚ùì Unknown artifact upload status: ${UPLOAD_OUTCOME}"
            echo "::warning::Unknown artifact upload status"
            ;;
        esac
        
        # Provide guidance for accessing artifacts
        if [[ "${UPLOAD_OUTCOME}" == "success" ]]; then
          echo ""
          echo "üí° To access the uploaded artifacts:"
          echo "  1. Go to the Actions tab in your GitHub repository"
          echo "  2. Click on this workflow run"
          echo "  3. Scroll down to the 'Artifacts' section"
          echo "  4. Download 'cloudformation-validation-results-${{ github.run_id }}'"
        fi
        
        echo "::endgroup::"
